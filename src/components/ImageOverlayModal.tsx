'use client';

import React, {
  useState,
  useRef,
  useCallback,
  useEffect,
  useMemo,
} from 'react';
import { useAppStore } from '@/store/useAppStore';
import { X, Loader2 } from 'lucide-react';
import { getSceneById } from '@/lib/baserow-actions';
// fonts mapping generated by scripts/generate_ffmpeg_fonts.py
// this file contains a mapping of family => sample font path present on the machine
import ffmpegFonts from '../../docs/ffmpeg-fonts.json';
import { Cropper, CropperRef } from 'react-advanced-cropper';
import 'react-advanced-cropper/dist/style.css';

import { ImageUploadRow } from './image-overlay-modal/ImageUploadRow';
import { ImagePositionControls } from './image-overlay-modal/ImagePositionControls';
import { TimingTintControls } from './image-overlay-modal/TimingTintControls';
import { TranscriptionControls } from './image-overlay-modal/TranscriptionControls';
import { TextOverlayControls } from './image-overlay-modal/TextOverlayControls';
import type {
  TextStyling,
  TranscriptionWord,
} from './image-overlay-modal/types';

// Helper function to convert hex color to RGB
const hexToRgb = (hex: string) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
        result[3],
        16
      )}`
    : '0, 0, 0';
};

interface ImageOverlayModalProps {
  isOpen: boolean;
  onClose: () => void;
  videoUrl: string;
  sceneId: number;
  onApply: (
    sceneId: number,
    overlayImage: File | null,
    overlayText: string | null,
    position: { x: number; y: number },
    size: { width: number; height: number },
    startTime: number,
    endTime: number,
    textStyling?: TextStyling,
    videoTintColor?: string | null,
    videoTintOpacity?: number
  ) => Promise<void>;
  isApplying?: boolean;
  handleTranscribeScene?: (
    sceneId: number,
    sceneData?: unknown,
    videoType?: 'original' | 'final',
    skipRefresh?: boolean,
    skipSound?: boolean
  ) => Promise<void>;
  onUpdateModalVideoUrl?: (videoUrl: string) => void;
}

export const ImageOverlayModal: React.FC<ImageOverlayModalProps> = ({
  isOpen,
  onClose,
  videoUrl,
  sceneId,
  onApply,
  isApplying = false,
  handleTranscribeScene,
  onUpdateModalVideoUrl,
}) => {
  const [overlayImage, setOverlayImage] = useState<File | null>(null);
  const [overlayImageUrl, setOverlayImageUrl] = useState<string | null>(null);
  const [overlayPosition, setOverlayPosition] = useState({ x: 50, y: 50 }); // percentage
  const [overlaySize, setOverlaySize] = useState({ width: 40, height: 40 }); // percentage
  const [startTime, setStartTime] = useState(0);
  const [endTime, setEndTime] = useState(0);
  const [videoTintColor, setVideoTintColor] = useState<string | null>(null);
  const [currentVideoTime, setCurrentVideoTime] = useState(0);
  const [videoTintOpacity, setVideoTintOpacity] = useState(1);
  const [isTintSectionOpen, setIsTintSectionOpen] = useState(false);
  const [isTextStylingSectionOpen, setIsTextStylingSectionOpen] =
    useState(false);
  const tintPalette = useMemo(
    () => [
      '#000000',
      '#FFFFFF',
      '#DDC57A',
      '#00FF00',
      '#0000FF',
      '#FFFF00',
      '#FF00FF',
      '#00FFFF',
      '#FFA500',
    ],
    []
  );
  const [, setIsDragging] = useState(false);
  const [, setIsResizing] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [transcriptionWords, setTranscriptionWords] = useState<
    TranscriptionWord[] | null
  >(null);
  const [selectedWordText, setSelectedWordText] = useState<string | null>(null);
  const [customText, setCustomText] = useState<string>('');
  const [textOverlayPosition, setTextOverlayPosition] = useState({
    x: 50,
    y: 50,
  }); // percentage
  const [textOverlaySize, setTextOverlaySize] = useState({
    width: 100,
    height: 100,
  }); // percentage
  const [textStyling, setTextStyling] = useState<TextStyling>(() => {
    // Load default styling from localStorage, or use fallback defaults
    const saved = localStorage.getItem('defaultTextStyling');
    return saved
      ? JSON.parse(saved)
      : {
          fontColor: '#ffffff',
          borderWidth: 3,
          borderColor: '#000000',
          shadowX: 8,
          shadowY: 8,
          shadowColor: '#000000',
          shadowOpacity: 0.9,
          fontFamily: 'Helvetica',
          // Background (box) settings for text overlay
          bgColor: '#000000',
          bgOpacity: 0.65,
          bgSize: 8, // px padding for background around text
        };
  });
  // Saved text styling presets, persisted in localStorage
  const [savedTextStyles, setSavedTextStyles] = useState<
    { name: string; style: TextStyling }[]
  >([]);
  const [isFontLoaded, setIsFontLoaded] = useState<boolean>(false);
  const [showFontPreview, setShowFontPreview] = useState<boolean>(false);

  // Load saved styles from localStorage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem('savedTextStyles');
      if (stored) {
        console.log('Loading savedTextStyles from localStorage:', stored);
        const parsed = JSON.parse(stored) as {
          name: string;
          style: TextStyling;
        }[];
        setSavedTextStyles(parsed);
      }
    } catch (e) {
      console.error('Failed to load saved text styles:', e);
    }
  }, []);

  // Check whether the selected font family is loaded by the browser for live preview
  useEffect(() => {
    const family = textStyling.fontFamily;
    if (!family || typeof document === 'undefined' || !document.fonts) {
      setIsFontLoaded(false);
      return;
    }

    // Check if the font is available already
    (async () => {
      try {
        // Try to load a tiny variation and check if loaded
        await document.fonts.load(`12px "${family}"`);
        const loaded = document.fonts.check(`12px "${family}"`);
        setIsFontLoaded(loaded);
      } catch {
        setIsFontLoaded(false);
      }
    })();
  }, [textStyling.fontFamily]);

  // Build a list of fonts from the JSON mapping and fall back to a small default set
  const availableFontFamilies = useMemo(() => {
    const mapping = ffmpegFonts as Record<string, string>;
    const keys = Object.keys(mapping || {}).filter(
      (k) => k !== 'user_fonts_dir'
    );
    if (keys.length > 0) return keys.sort();
    // fallback:
    return ['Helvetica', 'Arial', 'Courier', 'Times', 'Menlo'];
  }, []);

  // Previously we wrote savedTextStyles on every state change, which could
  // overwrite loaded values on mount due to timing; we now only write to
  // localStorage explicitly when saving/deleting presets so we avoid race conditions.

  const saveCurrentTextStyle = useCallback(() => {
    const name = prompt('Enter a name for this text style preset');
    if (!name) return;
    // avoid duplicates
    if (savedTextStyles.some((s) => s.name === name)) {
      alert('A preset with that name already exists');
      return;
    }
    console.log('Saving preset', name, textStyling);
    setSavedTextStyles((prev) => {
      const next = [...prev, { name, style: textStyling }];
      try {
        localStorage.setItem('savedTextStyles', JSON.stringify(next));
        console.log('Saved preset to localStorage', next);
      } catch (e) {
        console.error('Failed to persist savedTextStyles during save', e);
      }
      return next;
    });
  }, [savedTextStyles, textStyling]);

  const applySavedTextStyle = useCallback(
    (preset: { name: string; style: TextStyling }) => {
      setTextStyling(preset.style);
    },
    []
  );

  const deleteSavedTextStyle = useCallback((name: string) => {
    if (!confirm(`Delete preset ${name}?`)) return;
    setSavedTextStyles((prev) => {
      const next = prev.filter((s) => s.name !== name);
      try {
        localStorage.setItem('savedTextStyles', JSON.stringify(next));
        console.log('Updated localStorage after delete', next);
      } catch (e) {
        console.error('Failed to persist savedTextStyles during delete', e);
      }
      return next;
    });
  }, []);
  const [, setIsDraggingText] = useState(false);
  const [, setIsResizingText] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [refetchTrigger, setRefetchTrigger] = useState(0);
  const [containerRect, setContainerRect] = useState<{
    width: number;
    height: number;
  } | null>(null);
  const [videoToCssScale, setVideoToCssScale] = useState(1);

  // Cropping state
  const [isCropping, setIsCropping] = useState(false);
  const cropperRef = useRef<CropperRef>(null);

  // Actual image dimensions in pixels
  const [actualImageDimensions, setActualImageDimensions] = useState<{
    width: number;
    height: number;
  } | null>(null);

  // Store the original video URL when the modal opens
  const [originalVideoUrl, setOriginalVideoUrl] = useState<string | null>(null);

  const videoRef = useRef<HTMLVideoElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null!);
  const previewVideoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (!isOpen) return;
    const video = videoRef.current;
    if (!video) return;

    const update = () => setCurrentVideoTime(video.currentTime || 0);
    video.addEventListener('timeupdate', update);
    video.addEventListener('seeked', update);
    update();

    return () => {
      video.removeEventListener('timeupdate', update);
      video.removeEventListener('seeked', update);
    };
  }, [isOpen, originalVideoUrl]);

  const isTintActive =
    !!videoTintColor &&
    Number.isFinite(startTime) &&
    Number.isFinite(endTime) &&
    currentVideoTime >= startTime &&
    currentVideoTime <= endTime;

  const clamp01 = useCallback((v: number) => Math.max(0, Math.min(1, v)), []);

  // Keep a scale factor so CSS preview sizes (px) match FFmpeg drawtext sizes (video px).
  // Example: borderw=3 in FFmpeg should appear as ~3px on the source video, which is
  // borderw * (displayedVideoPx / sourceVideoPx) in the browser preview.
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const rect = containerRect ?? video.getBoundingClientRect();
    if (!rect?.width || !rect?.height) return;
    if (!video.videoWidth || !video.videoHeight) return;

    const scaleX = rect.width / video.videoWidth;
    const scaleY = rect.height / video.videoHeight;
    const next = Math.min(scaleX, scaleY);
    if (Number.isFinite(next) && next > 0) setVideoToCssScale(next);
  }, [containerRect, originalVideoUrl]);

  const getVideoContentRect = useCallback(() => {
    const video = videoRef.current;
    if (!video) return null;

    // Use the video element's rect for overlay positioning
    const rect = video.getBoundingClientRect();
    return rect;
  }, []);

  const handleImageUpload = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file && file.type.startsWith('image/')) {
        setOverlayImage(file);
        const url = URL.createObjectURL(file);
        setOverlayImageUrl(url);
        // Clear text overlay when adding image
        setSelectedWordText(null);
        setCustomText('');

        const img = new Image();
        img.onload = () => {
          setActualImageDimensions({ width: img.width, height: img.height });

          // Set overlay size to show image at its actual pixel dimensions
          // Assuming HD video (1920x1080), calculate percentage to show actual size
          const videoWidth = 1920; // Assume HD width
          const videoHeight = 1080; // Assume HD height

          const widthPercent = (img.width / videoWidth) * 100;
          const heightPercent = (img.height / videoHeight) * 100;

          setOverlaySize({
            width: Math.min(widthPercent, 100),
            height: Math.min(heightPercent, 100),
          });
        };
        img.src = url;
      }
    },
    []
  );

  const handleRemoveImage = useCallback(() => {
    setOverlayImage(null);
    setOverlayImageUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, []);

  const handleScreenshot = useCallback(() => {
    const video = videoRef.current;
    if (!video) return;

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      canvas.toBlob((blob) => {
        if (blob) {
          const file = new File([blob], 'screenshot.png', {
            type: 'image/png',
          });
          setOverlayImage(file);
          const url = URL.createObjectURL(file);
          setOverlayImageUrl(url);
          // Clear text overlay when adding image
          setSelectedWordText(null);
          setCustomText('');

          setActualImageDimensions({
            width: canvas.width,
            height: canvas.height,
          });

          // Set overlay size to show image at its actual pixel dimensions
          // Assuming HD video (1920x1080), calculate percentage to show actual size
          const videoWidth = 1920; // Assume HD width
          const videoHeight = 1080; // Assume HD height

          const widthPercent = (canvas.width / videoWidth) * 100;
          const heightPercent = (canvas.height / videoHeight) * 100;

          setOverlaySize({
            width: Math.min(widthPercent, 100),
            height: Math.min(heightPercent, 100),
          });
        }
      }, 'image/png');
    }
  }, []);

  const handleCopyOverlayImageToClipboard = useCallback(async () => {
    if (!overlayImage) return;

    try {
      const clipboard = navigator.clipboard;
      type ClipboardItemConstructor = new (
        items: Record<string, Blob>
      ) => ClipboardItem;
      const ClipboardItemCtor = (
        window as unknown as {
          ClipboardItem?: ClipboardItemConstructor;
        }
      ).ClipboardItem;

      if (!clipboard?.write || !ClipboardItemCtor) {
        alert('Copying images to clipboard is not supported in this browser.');
        return;
      }

      const mime = overlayImage.type || 'image/png';
      await clipboard.write([
        new ClipboardItemCtor({
          [mime]: overlayImage,
        }),
      ]);
    } catch (e) {
      console.error('Failed to copy overlay image to clipboard:', e);
      alert(
        'Failed to copy image to clipboard. Your browser may be blocking clipboard access.'
      );
    }
  }, [overlayImage]);

  const handlePasteOverlayImageFromClipboard = useCallback(async () => {
    try {
      const clipboard = navigator.clipboard;
      if (!clipboard?.read) {
        alert(
          'Pasting images from clipboard is not supported in this browser.'
        );
        return;
      }

      const items = await clipboard.read();
      let imageType: string | undefined;
      let imageBlob: Blob | null = null;

      for (const item of items) {
        const t = (item.types || []).find((x) => x.startsWith('image/'));
        if (!t) continue;
        imageType = t;
        imageBlob = await item.getType(t);
        break;
      }

      if (!imageBlob || !imageType) {
        alert('Clipboard does not contain an image.');
        return;
      }

      const ext = imageType.split('/')[1] || 'png';
      const file = new File([imageBlob], `clipboard-image.${ext}`, {
        type: imageType,
      });

      setOverlayImage(file);
      const url = URL.createObjectURL(file);
      setOverlayImageUrl(url);
      // Clear text overlay when adding image
      setSelectedWordText(null);
      setCustomText('');

      // Calculate aspect ratio + overlay size similarly to upload/screenshot
      const img = new Image();
      img.onload = () => {
        setActualImageDimensions({ width: img.width, height: img.height });

        const videoWidth = 1920;
        const videoHeight = 1080;
        const widthPercent = (img.width / videoWidth) * 100;
        const heightPercent = (img.height / videoHeight) * 100;
        setOverlaySize({
          width: Math.min(widthPercent, 100),
          height: Math.min(heightPercent, 100),
        });
      };
      img.src = url;
    } catch (e) {
      console.error('Failed to paste overlay image from clipboard:', e);
      alert(
        'Failed to paste image from clipboard. Your browser may be blocking clipboard access.'
      );
    }
  }, []);

  const applyCrop = useCallback(async () => {
    console.log('applyCrop called');
    if (!cropperRef.current || !overlayImageUrl) {
      console.log('Missing cropperRef.current or overlayImageUrl');
      return;
    }

    const coordinates = cropperRef.current.getCoordinates();
    const canvas = cropperRef.current.getCanvas();

    console.log('Coordinates:', coordinates);
    console.log('Canvas:', canvas);

    if (!coordinates || !canvas) {
      console.log('Missing coordinates or canvas');
      return;
    }

    // Convert canvas to blob
    canvas.toBlob((blob) => {
      if (blob) {
        console.log('Blob created, size:', blob.size);
        const croppedFile = new File([blob], 'cropped-image.png', {
          type: 'image/png',
        });
        const croppedUrl = URL.createObjectURL(croppedFile);

        setOverlayImage(croppedFile);
        setOverlayImageUrl(croppedUrl);

        setActualImageDimensions({
          width: coordinates.width,
          height: coordinates.height,
        });

        // Auto-reset overlay size to cropped image natural size
        setOverlayPosition({ x: 50, y: 50 });
        const videoWidth = 1920; // Assume HD width
        const videoHeight = 1080; // Assume HD height

        const widthPercent = (coordinates.width / videoWidth) * 100;
        const heightPercent = (coordinates.height / videoHeight) * 100;

        setOverlaySize({
          width: Math.min(widthPercent, 100),
          height: Math.min(heightPercent, 100),
        });

        // Reset crop state
        setIsCropping(false);
        console.log('Crop applied successfully');
      } else {
        console.log('Failed to create blob');
      }
    }, 'image/png');
  }, [cropperRef, overlayImageUrl]);

  const handleVideoLoad = useCallback(() => {
    const video = videoRef.current;
    if (video && video.duration) {
      setEndTime(video.duration);

      // Update container rect when video loads
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    }
  }, [getVideoContentRect]);

  // Ensure video element updates when videoUrl changes
  useEffect(() => {
    const video = videoRef.current;
    if (video && originalVideoUrl && video.src !== originalVideoUrl) {
      video.src = originalVideoUrl;
      video.load();
    }
  }, [originalVideoUrl]);

  const handleMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!overlayImageUrl) return;

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if clicking on the overlay image
      const overlayX = overlayPosition.x - overlaySize.width / 2;
      const overlayY = overlayPosition.y - overlaySize.height / 2;

      // Convert to pixels
      const overlayX_px = (overlayX / 100) * contentRect.width;
      const overlayY_px = (overlayY / 100) * contentRect.height;
      const overlayWidth_px = (overlaySize.width / 100) * contentRect.width;
      const overlayHeight_px = (overlaySize.height / 100) * contentRect.height;

      // Check if clicking near edges/corners for resizing (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= overlayX_px - edgeThreshold && x <= overlayX_px + edgeThreshold;
      const nearRightEdge =
        x >= overlayX_px + overlayWidth_px - edgeThreshold &&
        x <= overlayX_px + overlayWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= overlayY_px - edgeThreshold && y <= overlayY_px + edgeThreshold;
      const nearBottomEdge =
        y >= overlayY_px + overlayHeight_px - edgeThreshold &&
        y <= overlayY_px + overlayHeight_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      if (isNearEdge) {
        // Start resizing - determine resize direction based on which edges are near
        const startX = event.clientX;
        const startY = event.clientY;
        const startSize = { ...overlaySize };
        const startPos = { ...overlayPosition };
        const pointerId = event.pointerId;

        setIsResizing(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          // Allow free resizing without maintaining aspect ratio
          // Handle horizontal resizing
          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2; // Move position to keep right edge in place
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width + deltaX);
          }

          // Handle vertical resizing
          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2; // Move position to keep bottom edge in place
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height + deltaY);
          }

          setOverlaySize({
            width: Math.min(newWidth, 100),
            height: Math.min(newHeight, 100),
          });

          // Update position if resizing from top/left
          if (nearLeftEdge || nearTopEdge) {
            setOverlayPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          setIsResizing(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      } else if (
        x >= overlayX_px &&
        x <= overlayX_px + overlayWidth_px &&
        y >= overlayY_px &&
        y <= overlayY_px + overlayHeight_px
      ) {
        // Start dragging (center area)
        const startX = event.clientX;
        const startY = event.clientY;
        const startPos = { ...overlayPosition };
        const pointerId = event.pointerId;

        setIsDragging(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;

          setOverlayPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          setIsDragging(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [overlayImageUrl, overlayPosition, overlaySize, getVideoContentRect]
  );

  const handleTextMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!selectedWordText) return;

      const contentRect = containerRect
        ? {
            width: containerRect.width,
            height: containerRect.height,
            left: 0,
            top: 0,
          }
        : getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if clicking on the text overlay (calculate based on text content using percentages)
      const textWidthPercent = Math.min(
        95,
        (selectedWordText.length <= 3
          ? 35
          : selectedWordText.length <= 7
          ? 55
          : selectedWordText.length <= 12
          ? 70
          : 85) *
          (textOverlaySize.width / 20)
      );
      const textHeightPercent = Math.max(
        10,
        Math.min(85, (textOverlaySize.width / 100) * 60)
      );
      const textX = textOverlayPosition.x - textWidthPercent / 2;
      const textY = textOverlayPosition.y - textHeightPercent / 2;

      // Convert to pixels
      const textX_px = (textX / 100) * contentRect.width;
      const textY_px = (textY / 100) * contentRect.height;
      const textWidth_px = (textWidthPercent / 100) * contentRect.width;
      const textHeight_px = (textHeightPercent / 100) * contentRect.height;

      // Check if clicking near edges/corners for resizing (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= textX_px - edgeThreshold && x <= textX_px + edgeThreshold;
      const nearRightEdge =
        x >= textX_px + textWidth_px - edgeThreshold &&
        x <= textX_px + textWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= textY_px - edgeThreshold && y <= textY_px + edgeThreshold;
      const nearBottomEdge =
        y >= textY_px + textHeight_px - edgeThreshold &&
        y <= textY_px + textHeight_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      if (isNearEdge) {
        // Start resizing - determine resize direction based on which edges are near
        const startX = event.clientX;
        const startY = event.clientY;
        const startSize = { ...textOverlaySize };
        const startPos = { ...textOverlayPosition };
        const pointerId = event.pointerId;

        setIsResizingText(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          // Handle horizontal resizing
          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2; // Move position to keep right edge in place
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width + deltaX);
          }

          // Handle vertical resizing
          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2; // Move position to keep bottom edge in place
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height + deltaY);
          }

          setTextOverlaySize({
            width: Math.min(newWidth, 100),
            height: Math.min(newHeight, 100),
          });

          // Update position if resizing from top/left
          if (nearLeftEdge || nearTopEdge) {
            setTextOverlayPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          setIsResizingText(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      } else if (
        x >= textX_px &&
        x <= textX_px + textWidth_px &&
        y >= textY_px &&
        y <= textY_px + textHeight_px
      ) {
        // Start dragging (center area)
        const startX = event.clientX;
        const startY = event.clientY;
        const startPos = { ...textOverlayPosition };
        const pointerId = event.pointerId;

        setIsDraggingText(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;

          setTextOverlayPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          setIsDraggingText(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [
      selectedWordText,
      textOverlayPosition,
      textOverlaySize,
      getVideoContentRect,
      containerRect,
    ]
  );

  const handlePointerMove = useCallback(
    (event: React.PointerEvent) => {
      if (!overlayImageUrl) return;

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if hovering near edges/corners for resizing
      const overlayX = overlayPosition.x - overlaySize.width / 2;
      const overlayY = overlayPosition.y - overlaySize.height / 2;

      // Convert to pixels
      const overlayX_px = (overlayX / 100) * contentRect.width;
      const overlayY_px = (overlayY / 100) * contentRect.height;
      const overlayWidth_px = (overlaySize.width / 100) * contentRect.width;
      const overlayHeight_px = (overlaySize.height / 100) * contentRect.height;

      // Check if hovering near edges/corners (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= overlayX_px - edgeThreshold && x <= overlayX_px + edgeThreshold;
      const nearRightEdge =
        x >= overlayX_px + overlayWidth_px - edgeThreshold &&
        x <= overlayX_px + overlayWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= overlayY_px - edgeThreshold && y <= overlayY_px + edgeThreshold;
      const nearBottomEdge =
        y >= overlayY_px + overlayHeight_px - edgeThreshold &&
        y <= overlayY_px + overlayHeight_px + edgeThreshold;

      // Set cursor based on position
      if (nearLeftEdge && nearTopEdge) {
        document.body.style.cursor = 'nw-resize';
      } else if (nearRightEdge && nearTopEdge) {
        document.body.style.cursor = 'ne-resize';
      } else if (nearLeftEdge && nearBottomEdge) {
        document.body.style.cursor = 'sw-resize';
      } else if (nearRightEdge && nearBottomEdge) {
        document.body.style.cursor = 'se-resize';
      } else if (nearLeftEdge || nearRightEdge) {
        document.body.style.cursor = 'ew-resize';
      } else if (nearTopEdge || nearBottomEdge) {
        document.body.style.cursor = 'ns-resize';
      } else if (
        x >= overlayX_px &&
        x <= overlayX_px + overlayWidth_px &&
        y >= overlayY_px &&
        y <= overlayY_px + overlayHeight_px
      ) {
        document.body.style.cursor = 'move';
      } else {
        document.body.style.cursor = 'default';
      }
    },
    [overlayImageUrl, overlayPosition, overlaySize, getVideoContentRect]
  );

  const handlePointerLeave = useCallback(() => {
    document.body.style.cursor = 'default';
  }, []);

  const handlePreview = useCallback(async () => {
    if (!overlayImage && !selectedWordText && !videoTintColor) return;
    if (!originalVideoUrl) return;
    console.log('handlePreview: textStyling', textStyling);

    const formData = new FormData();
    formData.append('videoUrl', originalVideoUrl);
    formData.append('sceneId', sceneId.toString());
    if (overlayImage) {
      formData.append('overlayImage', overlayImage);
    }
    if (selectedWordText) {
      formData.append('overlayText', selectedWordText);
    }
    formData.append(
      'positionX',
      (overlayImage ? overlayPosition.x : textOverlayPosition.x).toString()
    );
    formData.append(
      'positionY',
      (overlayImage ? overlayPosition.y : textOverlayPosition.y).toString()
    );
    formData.append(
      'sizeWidth',
      (overlayImage ? overlaySize.width : textOverlaySize.width).toString()
    );
    formData.append(
      'sizeHeight',
      (overlayImage ? overlaySize.height : textOverlaySize.height).toString()
    );
    formData.append('startTime', startTime.toString());
    formData.append('endTime', endTime.toString());
    formData.append('preview', 'true');
    if (videoTintColor) {
      formData.append('videoTintColor', videoTintColor);
      formData.append('videoTintOpacity', clamp01(videoTintOpacity).toString());
    }
    if (selectedWordText && textStyling) {
      formData.append('textStyling', JSON.stringify(textStyling));
    }

    try {
      const response = await fetch('/api/add-image-overlay', {
        method: 'POST',
        body: formData,
      });
      const data = await response.json();
      if (data.success) {
        setPreviewUrl(data.url);
      } else {
        alert('Preview failed: ' + data.error);
      }
    } catch {
      alert('Error generating preview');
    }
  }, [
    overlayImage,
    selectedWordText,
    videoTintColor,
    videoTintOpacity,
    originalVideoUrl,
    sceneId,
    overlayPosition,
    textOverlayPosition,
    overlaySize,
    textOverlaySize,
    startTime,
    endTime,
    textStyling,
    clamp01,
  ]);

  const handleApply = useCallback(async () => {
    if (!overlayImage && !selectedWordText && !videoTintColor) return;

    try {
      console.log(
        'handleApply: sending textStyling',
        selectedWordText ? textStyling : undefined
      );
      // Apply overlay to the CURRENT video playing in the modal
      await onApply(
        sceneId,
        overlayImage,
        selectedWordText,
        overlayImage ? overlayPosition : textOverlayPosition,
        overlayImage ? overlaySize : textOverlaySize,
        startTime,
        endTime,
        selectedWordText ? textStyling : undefined,
        videoTintColor,
        videoTintOpacity
      );

      // After applying, fetch the scene from the DB to get the updated video URL
      // Retry a few times in case the DB update hasn't fully propagated
      const maxRetries = 6;
      let attempts = 0;
      let sceneData: { field_6886?: unknown } | null = null;
      let newUrl: string | undefined;
      while (attempts < maxRetries) {
        sceneData = (await getSceneById(sceneId)) as {
          field_6886?: unknown;
        } | null;
        newUrl =
          typeof sceneData?.field_6886 === 'string'
            ? sceneData.field_6886
            : undefined;
        if (newUrl && newUrl !== originalVideoUrl) break;
        await new Promise((res) => setTimeout(res, 500));
        attempts++;
      }

      if (newUrl) {
        setOriginalVideoUrl(newUrl);
        // Notify parent so subsequent applies use the new video URL
        if (onUpdateModalVideoUrl) {
          onUpdateModalVideoUrl(newUrl);
        }
      }

      // Force a refetch of transcription and other modal data
      // but avoid triggering this refetch during batch operations to prevent
      // per-loop data refreshes that lead to UI flicker.
      if (!useAppStore.getState().batchOperations.transcribingAllFinalScenes) {
        setRefetchTrigger((prev) => prev + 1);
      }

      // Reset overlay state to defaults (like opening a fresh modal) but keep it open
      setOverlayImage(null);
      setOverlayImageUrl(null);
      setOverlayPosition({ x: 50, y: 50 });
      setOverlaySize({ width: 40, height: 40 });
      setPreviewUrl(null);
      setSelectedWordText(null);
      setCustomText('');
      setStartTime(0);
      setEndTime(0);
      setVideoTintColor(null);
      setVideoTintOpacity(1);
      setIsTintSectionOpen(false);
      setIsTextStylingSectionOpen(false);
      setIsCropping(false);
      setActualImageDimensions(null);
      setTextOverlayPosition({ x: 50, y: 50 });
      setTextOverlaySize({ width: 100, height: 100 });
      setTextStyling(() => {
        const saved = localStorage.getItem('defaultTextStyling');
        return saved
          ? JSON.parse(saved)
          : {
              fontColor: '#ffffff',
              borderWidth: 3,
              borderColor: '#000000',
              shadowX: 8,
              shadowY: 8,
              shadowColor: '#000000',
              shadowOpacity: 0.9,
              fontFamily: 'Helvetica',
              bgColor: '#000000',
              bgOpacity: 0.65,
              bgSize: 8,
            };
      });
    } catch (error) {
      console.error('Failed to apply overlay and refresh modal:', error);
    }
  }, [
    overlayImage,
    selectedWordText,
    textStyling,
    videoTintColor,
    videoTintOpacity,
    sceneId,
    overlayPosition,
    overlaySize,
    textOverlayPosition,
    textOverlaySize,
    startTime,
    endTime,
    onApply,
    onUpdateModalVideoUrl,
    originalVideoUrl,
  ]);

  const handleClose = useCallback(() => {
    onClose();
    // Reset state
    setOverlayImage(null);
    setOverlayImageUrl(null);
    setOverlayPosition({ x: 50, y: 50 });
    setOverlaySize({ width: 40, height: 40 });
    setStartTime(0);
    setEndTime(0);
    setVideoTintColor(null);
    setVideoTintOpacity(1);
    setIsTintSectionOpen(false);
    setIsTextStylingSectionOpen(false);
    setPreviewUrl(null);
    setTranscriptionWords(null);
    setSelectedWordText(null);
    setCustomText('');
    setSelectedWordText(null);
  }, [onClose]);

  // Fetch transcription data
  useEffect(() => {
    if (isOpen && sceneId) {
      setIsTintSectionOpen(false);
      setIsTextStylingSectionOpen(false);
      // Clear any leftover preview state when modal opens
      setPreviewUrl(null);
      // Set the original video URL when we have a valid video URL
      if (videoUrl && videoUrl.trim() !== '') {
        setOriginalVideoUrl(videoUrl);
      }

      const fetchTranscription = async () => {
        try {
          // Fetch scene data from Baserow to get the Captions URL
          const sceneData = await getSceneById(sceneId);

          // Try different possible field names and specific field IDs
          let captionsUrl = null;

          // First try the specific field that contains captions URL
          if (
            sceneData?.['field_6910'] &&
            typeof sceneData['field_6910'] === 'string' &&
            (sceneData['field_6910'].startsWith('http') ||
              sceneData['field_6910'].includes('.json'))
          ) {
            captionsUrl = sceneData['field_6910'];
          }

          // Then try other possible field names
          if (!captionsUrl) {
            captionsUrl =
              sceneData?.['Captions URL'] ||
              sceneData?.['captions_url'] ||
              sceneData?.['CaptionsURL'] ||
              sceneData?.['captions URL'];
          }

          // Finally try other field IDs that might contain captions (only if they look like URLs)
          if (!captionsUrl) {
            const possibleFields = [
              'field_6892',
              'field_6893',
              'field_6894',
              'field_6895',
              'field_6897',
              'field_6898',
              'field_6899',
            ];
            for (const field of possibleFields) {
              const value = sceneData?.[field];
              if (
                value &&
                typeof value === 'string' &&
                (value.startsWith('http') || value.includes('.json'))
              ) {
                captionsUrl = value;
                break;
              }
            }
          }

          if (captionsUrl) {
            const response = await fetch(captionsUrl as string);
            if (response.ok) {
              const data = await response.json();
              setTranscriptionWords(data);
            } else {
              setTranscriptionWords(null);
            }
          } else {
            setTranscriptionWords(null);
          }
        } catch (error) {
          console.error('Failed to fetch transcription:', error);
          setTranscriptionWords(null);
        }
      };
      fetchTranscription();
    } else {
      // Modal is closed, clear transcription data
      setTranscriptionWords(null);
    }
  }, [isOpen, sceneId, refetchTrigger, videoUrl]);

  // Handle keyboard controls
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.code === 'Escape') {
        if (previewUrl) {
          setPreviewUrl(null);
        } else {
          handleClose();
        }
        return;
      }

      if (event.code === 'Space') {
        // If an input or editable element is focused, allow the spacebar to
        // insert text rather than control player playback.
        const target = event.target as Element | null;
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return; // allow normal typing behavior
        }

        event.preventDefault();
        const video = previewUrl ? previewVideoRef.current : videoRef.current;
        if (video) {
          if (video.paused) {
            video.play();
          } else {
            video.pause();
          }
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [previewUrl, handleClose]);

  // Update container dimensions
  useEffect(() => {
    const updateContainerRect = () => {
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    };

    // Update immediately
    updateContainerRect();

    // Update on window resize
    window.addEventListener('resize', updateContainerRect);
    return () => window.removeEventListener('resize', updateContainerRect);
  }, [getVideoContentRect]);

  // Update container dimensions
  useEffect(() => {
    const updateContainerRect = () => {
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    };

    // Update immediately
    updateContainerRect();

    // Update on window resize
    window.addEventListener('resize', updateContainerRect);
    return () => window.removeEventListener('resize', updateContainerRect);
  }, [getVideoContentRect]);

  if (!isOpen) return null;

  return (
    <div className='fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'>
      <div className='bg-white rounded-lg p-8 w-full mx-2 h-[95vh] overflow-hidden'>
        <div className='flex justify-between items-center mb-4'>
          <h2 className='text-xl font-semibold'>Add Image Overlay</h2>
          <button
            onClick={handleClose}
            className='p-1 hover:bg-gray-100 rounded'
          >
            <X className='h-5 w-5' />
          </button>
        </div>

        <div className='grid grid-cols-1 lg:grid-cols-3 gap-6'>
          {/* Video Preview */}
          <div
            className='relative lg:col-span-2'
            onPointerDown={handleMouseDown}
            onPointerMove={handlePointerMove}
            onPointerLeave={handlePointerLeave}
          >
            {originalVideoUrl ? (
              <video
                key={originalVideoUrl}
                ref={videoRef}
                src={originalVideoUrl}
                className='w-full h-full object-contain rounded border'
                controls
                crossOrigin='anonymous'
                onLoadedMetadata={handleVideoLoad}
              />
            ) : (
              <div className='w-full h-full flex items-center justify-center bg-gray-100 rounded border'>
                <div className='text-gray-500 text-center'>
                  <div className='text-lg mb-2'>ðŸ“¹</div>
                  <div>Loading video...</div>
                </div>
              </div>
            )}
            {isTintActive && videoTintColor && (
              <div
                className='absolute pointer-events-none'
                style={{
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: videoTintColor,
                  opacity: clamp01(videoTintOpacity),
                }}
              />
            )}
            {/* Invisible overlay to capture clicks when there's an overlay - excludes controls area */}
            {overlayImageUrl && (
              <div
                className='absolute pointer-events-auto z-5'
                style={{
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: '40px', // Leave space for video controls at bottom
                }}
                onPointerDown={(e) => {
                  // Only prevent default if clicking in overlay area
                  const contentRect = getVideoContentRect();
                  if (!contentRect) return;

                  const x = e.clientX - contentRect.left;
                  const y = e.clientY - contentRect.top;

                  const overlayX = overlayPosition.x - overlaySize.width / 2;
                  const overlayY = overlayPosition.y - overlaySize.height / 2;
                  const overlayX_px = (overlayX / 100) * contentRect.width;
                  const overlayY_px = (overlayY / 100) * contentRect.height;
                  const overlayWidth_px =
                    (overlaySize.width / 100) * contentRect.width;
                  const overlayHeight_px =
                    (overlaySize.height / 100) * contentRect.height;

                  // If clicking within overlay bounds, handle overlay interaction
                  if (
                    x >= overlayX_px &&
                    x <= overlayX_px + overlayWidth_px &&
                    y >= overlayY_px &&
                    y <= overlayY_px + overlayHeight_px
                  ) {
                    handleMouseDown(e);
                  } else {
                    // Outside overlay - allow video surface clicks (but not controls)
                    // This will still prevent accidental play/pause on video surface
                    e.preventDefault();
                  }
                }}
              />
            )}
            {overlayImageUrl && (
              <div
                className='absolute border-2 border-blue-500 cursor-move pointer-events-auto z-20'
                style={{
                  left: `${overlayPosition.x}%`,
                  top: `${overlayPosition.y}%`,
                  width: `${overlaySize.width}%`,
                  height: `${overlaySize.height}%`,
                  transform: 'translate(-50%, -50%)',
                }}
                onPointerDown={handleMouseDown}
              >
                <img
                  src={overlayImageUrl}
                  alt='Overlay'
                  className='w-full h-full object-contain'
                  draggable={false}
                  onPointerDown={handleMouseDown}
                />
              </div>
            )}
            {selectedWordText && (
              <div
                className='absolute border border-green-500 cursor-move pointer-events-auto z-10 rounded'
                style={{
                  left: `${textOverlayPosition.x}%`,
                  top: `${textOverlayPosition.y}%`,
                  transform: 'translate(-50%, -50%)',
                  width: `${Math.max(
                    5,
                    Math.min(
                      95,
                      (selectedWordText.length <= 3
                        ? 35
                        : selectedWordText.length <= 7
                        ? 55
                        : selectedWordText.length <= 12
                        ? 70
                        : 85) *
                        (textOverlaySize.width / 20)
                    ) * 0.5
                  )}%`,
                  height: `${Math.max(
                    5,
                    Math.max(
                      10,
                      Math.min(85, (textOverlaySize.width / 100) * 60)
                    ) * 0.5
                  )}%`,
                  // Match server-side font sizing (in video pixels), then scale to CSS pixels.
                  fontSize: `${(() => {
                    const v = videoRef.current;
                    if (!v?.videoWidth || !v?.videoHeight) {
                      return Math.max(8, (textOverlaySize.width / 100) * 120);
                    }
                    const fontSizeVideoPx = Math.max(
                      16,
                      Math.min(
                        500,
                        (textOverlaySize.width / 100) *
                          Math.min(v.videoWidth, v.videoHeight) *
                          0.2
                      )
                    );
                    return Math.max(1, fontSizeVideoPx * videoToCssScale);
                  })()}px`,
                }}
                onPointerDown={handleTextMouseDown}
              >
                <div
                  className='w-full h-full flex items-center justify-center font-bold select-none whitespace-nowrap'
                  style={{
                    color: textStyling.fontColor,
                    textShadow: `${textStyling.shadowX * videoToCssScale}px ${
                      textStyling.shadowY * videoToCssScale
                    }px 0px rgba(${hexToRgb(textStyling.shadowColor)}, ${
                      textStyling.shadowOpacity
                    })`,
                    WebkitTextStroke:
                      textStyling.borderWidth > 0
                        ? `${textStyling.borderWidth * videoToCssScale}px ${
                            textStyling.borderColor
                          }`
                        : 'none',
                    fontWeight: 'bold',
                    fontFamily: textStyling.fontFamily,
                    backgroundColor: textStyling.bgColor
                      ? `rgba(${hexToRgb(textStyling.bgColor)}, ${
                          textStyling.bgOpacity ?? 1
                        })`
                      : undefined,
                    padding: textStyling.bgSize
                      ? `${textStyling.bgSize * videoToCssScale}px`
                      : undefined,
                    borderRadius: textStyling.bgSize ? '4px' : undefined,
                  }}
                >
                  {selectedWordText}
                </div>
              </div>
            )}
          </div>

          {/* Controls */}
          <div className='space-y-4'>
            {/* Image Upload */}
            <ImageUploadRow
              fileInputRef={fileInputRef}
              overlayImage={overlayImage}
              onImageUpload={handleImageUpload}
              onPickFile={() => fileInputRef.current?.click()}
              onScreenshot={handleScreenshot}
              onCopyToClipboard={handleCopyOverlayImageToClipboard}
              onPasteFromClipboard={handlePasteOverlayImageFromClipboard}
              onRemoveImage={handleRemoveImage}
            />

            {/* Position Controls */}
            {/* Position and Size Controls */}
            {overlayImageUrl && (
              <ImagePositionControls
                overlayPosition={overlayPosition}
                setOverlayPosition={setOverlayPosition}
                overlaySize={overlaySize}
                setOverlaySize={setOverlaySize}
                actualImageDimensions={actualImageDimensions}
                onCrop={() => setIsCropping(true)}
                onCenterResetNatural={() => {
                  setOverlayPosition({ x: 50, y: 50 });
                  if (actualImageDimensions) {
                    const videoWidth = 1920;
                    const videoHeight = 1080;
                    const widthPercent =
                      (actualImageDimensions.width / videoWidth) * 100;
                    const heightPercent =
                      (actualImageDimensions.height / videoHeight) * 100;
                    setOverlaySize({
                      width: Math.min(widthPercent, 100),
                      height: Math.min(heightPercent, 100),
                    });
                  } else {
                    setOverlaySize({ width: 25, height: 25 });
                  }
                }}
                onCenterMaximize={() => {
                  setOverlayPosition({ x: 50, y: 50 });
                  setOverlaySize({ width: 100, height: 100 });
                }}
                onZoomOut={() => {
                  setOverlaySize((prev) => ({
                    width: Math.max(5, prev.width * 0.9),
                    height: Math.max(5, prev.height * 0.9),
                  }));
                }}
                onZoomIn={() => {
                  setOverlaySize((prev) => ({
                    width: Math.min(100, prev.width * 1.1),
                    height: Math.min(100, prev.height * 1.1),
                  }));
                }}
              />
            )}

            {/* Timing Controls */}
            <TimingTintControls
              startTime={startTime}
              endTime={endTime}
              setStartTime={(v) => setStartTime(v)}
              setEndTime={(v) => setEndTime(v)}
              onSetStartFromCurrent={() => {
                const video = videoRef.current;
                if (video) setStartTime(video.currentTime);
              }}
              onSetEndFromCurrent={() => {
                const video = videoRef.current;
                if (video) setEndTime(video.currentTime);
              }}
              isTintSectionOpen={isTintSectionOpen}
              setIsTintSectionOpen={setIsTintSectionOpen}
              tintPalette={tintPalette}
              videoTintColor={videoTintColor}
              setVideoTintColor={setVideoTintColor}
              videoTintOpacity={videoTintOpacity}
              setVideoTintOpacity={setVideoTintOpacity}
              clamp01={clamp01}
            />

            <TranscriptionControls
              transcriptionWords={transcriptionWords}
              customText={customText}
              selectedWordText={selectedWordText}
              onWordClick={(wordData) => {
                setStartTime(wordData.start);
                setCustomText((wordData.word || '').toUpperCase());
                if (videoRef.current) {
                  videoRef.current.currentTime = wordData.start;
                }
              }}
              onCustomTextChange={setCustomText}
              onCustomTextEnter={() => {
                if (customText.trim()) {
                  setSelectedWordText(customText.trim());
                  setOverlayImage(null);
                  setOverlayImageUrl(null);
                  if (fileInputRef.current) fileInputRef.current.value = '';
                }
              }}
              onAddText={() => {
                if (customText.trim()) {
                  setSelectedWordText(customText.trim());
                  setOverlayImage(null);
                  setOverlayImageUrl(null);
                  if (fileInputRef.current) fileInputRef.current.value = '';
                }
              }}
              onClearText={() => {
                setSelectedWordText(null);
                setCustomText('');
                setPreviewUrl(null);
              }}
              onInsertFull={() => {
                if (transcriptionWords && transcriptionWords.length > 0) {
                  const allText = transcriptionWords
                    .map((w) => w.word)
                    .join(' ');
                  setCustomText((allText || '').toUpperCase());
                }
              }}
              canTranscribe={!!handleTranscribeScene}
              onTranscribe={async () => {
                if (!handleTranscribeScene) return;
                setIsTranscribing(true);
                try {
                  await handleTranscribeScene(sceneId, undefined, 'final');
                  if (
                    !useAppStore.getState().batchOperations
                      .transcribingAllFinalScenes
                  ) {
                    setRefetchTrigger((prev) => prev + 1);
                  }
                } catch (error) {
                  console.error('Failed to transcribe:', error);
                } finally {
                  setIsTranscribing(false);
                }
              }}
              onRetranscribe={async () => {
                if (!handleTranscribeScene) return;
                setIsTranscribing(true);
                try {
                  await handleTranscribeScene(sceneId, undefined, 'final');
                  if (
                    !useAppStore.getState().batchOperations
                      .transcribingAllFinalScenes
                  ) {
                    setRefetchTrigger((prev) => prev + 1);
                  }
                } catch (error) {
                  console.error('Failed to retranscribe:', error);
                } finally {
                  setIsTranscribing(false);
                }
              }}
              isTranscribing={isTranscribing}
              isInsertFullDisabled={
                !transcriptionWords ||
                transcriptionWords.length === 0 ||
                customText.trim() ===
                  (transcriptionWords || [])
                    .map((w) => w.word)
                    .join(' ')
                    .trim()
              }
            />

            {selectedWordText && (
              <TextOverlayControls
                textOverlayPosition={textOverlayPosition}
                setTextOverlayPosition={setTextOverlayPosition}
                textOverlaySize={textOverlaySize}
                setTextOverlaySize={setTextOverlaySize}
                isTextStylingSectionOpen={isTextStylingSectionOpen}
                setIsTextStylingSectionOpen={setIsTextStylingSectionOpen}
                textStyling={textStyling}
                setTextStyling={setTextStyling}
                ffmpegFonts={ffmpegFonts as Record<string, string>}
                availableFontFamilies={availableFontFamilies}
                showFontPreview={showFontPreview}
                setShowFontPreview={setShowFontPreview}
                isFontLoaded={isFontLoaded}
                saveCurrentTextStyle={saveCurrentTextStyle}
                savedTextStyles={savedTextStyles}
                applySavedTextStyle={applySavedTextStyle}
                deleteSavedTextStyle={deleteSavedTextStyle}
              />
            )}
          </div>
        </div>

        {/* Action Buttons */}
        <div className='flex justify-end space-x-3 mt-6 pt-4 border-t'>
          <button
            onClick={handleClose}
            className='px-4 py-2 text-gray-600 hover:bg-gray-100 rounded'
            disabled={isApplying}
          >
            Cancel
          </button>
          <button
            onClick={handlePreview}
            disabled={
              !(overlayImage || selectedWordText || videoTintColor) ||
              isApplying
            }
            className='px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed'
          >
            Preview
          </button>
          <button
            onClick={handleApply}
            disabled={
              !(overlayImage || selectedWordText || videoTintColor) ||
              isApplying
            }
            className='flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed'
          >
            {isApplying ? (
              <Loader2 className='animate-spin h-4 w-4' />
            ) : (
              <span>Apply Overlay</span>
            )}
          </button>
        </div>
      </div>

      {/* Cropping Modal */}
      {isCropping && overlayImageUrl && (
        <div className='fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'>
          <div className='bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] w-full mx-4'>
            <div className='flex justify-between items-center mb-4'>
              <h3 className='text-lg font-semibold'>Crop Image</h3>
              <button
                onClick={() => {
                  setIsCropping(false);
                }}
                className='p-1 hover:bg-gray-100 rounded'
              >
                <X className='h-5 w-5' />
              </button>
            </div>

            <div className='flex flex-col items-center space-y-4'>
              <div className='flex space-x-4 w-full'>
                <div className='flex-1'>
                  <h4 className='text-sm font-medium mb-2'>Select Crop Area</h4>
                  <div className='max-h-[50vh] overflow-auto border rounded'>
                    <div
                      className='relative h-96 w-full border bg-gray-100'
                      style={{ minHeight: '384px' }}
                    >
                      <Cropper
                        key={overlayImageUrl}
                        src={overlayImageUrl}
                        ref={cropperRef}
                        className={'w-full h-full'}
                        style={{
                          height: '100%',
                          width: '100%',
                          backgroundColor: '#f3f4f6',
                        }}
                        stencilProps={{
                          aspectRatio: undefined,
                        }}
                        checkOrientation={false}
                        onReady={() => {
                          console.log(
                            'Cropper ready, ref:',
                            cropperRef.current
                          );
                        }}
                      />
                    </div>
                  </div>
                </div>
              </div>

              <div className='flex space-x-2'>
                <button
                  onClick={() => {
                    setIsCropping(false);
                  }}
                  className='px-4 py-2 border border-gray-300 rounded hover:bg-gray-50'
                >
                  Cancel
                </button>
                <button
                  onClick={async () => {
                    console.log(
                      'Apply crop clicked, cropperRef.current:',
                      cropperRef.current
                    );
                    console.log('overlayImage:', overlayImage);
                    if (cropperRef.current && overlayImage) {
                      console.log('Calling applyCrop');
                      await applyCrop();
                    } else {
                      console.log('Conditions not met for applyCrop');
                    }
                  }}
                  className='px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600'
                  disabled={!overlayImage}
                >
                  Apply Crop
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Preview Video Overlay */}
      {previewUrl && (
        <div
          className='fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'
          onClick={() => setPreviewUrl(null)}
        >
          <div className='relative max-w-4xl max-h-[80vh] w-full mx-4'>
            <button
              onClick={(e) => {
                e.stopPropagation();
                setPreviewUrl(null);
              }}
              className='absolute -top-10 right-0 text-white hover:text-gray-300 text-xl font-bold'
            >
              âœ•
            </button>
            <video
              src={previewUrl as string}
              controls
              autoPlay
              crossOrigin='anonymous'
              className='w-full h-full rounded-lg'
              onClick={(e) => e.stopPropagation()}
              ref={previewVideoRef}
            />
          </div>
        </div>
      )}
    </div>
  );
};
