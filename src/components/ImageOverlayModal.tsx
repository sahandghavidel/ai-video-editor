'use client';

import React, {
  useState,
  useRef,
  useCallback,
  useEffect,
  useMemo,
} from 'react';
import { useAppStore } from '@/store/useAppStore';
import { X, Loader2, ChevronDown, ChevronRight } from 'lucide-react';
import { getSceneById } from '@/lib/baserow-actions';
// fonts mapping generated by scripts/generate_ffmpeg_fonts.py
// this file contains a mapping of family => sample font path present on the machine
import ffmpegFonts from '../../docs/ffmpeg-fonts.json';
import {
  Cropper,
  CropperRef,
  CircleStencil,
  ImageRestriction,
} from 'react-advanced-cropper';
import 'react-advanced-cropper/dist/style.css';
import { getBackgroundStyle } from 'advanced-cropper';

import { ImageUploadRow } from './image-overlay-modal/ImageUploadRow';
import { ImagePositionControls } from './image-overlay-modal/ImagePositionControls';
import { TimingTintControls } from './image-overlay-modal/TimingTintControls';
import { TranscriptionControls } from './image-overlay-modal/TranscriptionControls';
import { TextOverlayControls } from './image-overlay-modal/TextOverlayControls';
import { VideoEditModal } from './VideoEditModal';
import type {
  TextStyling,
  TranscriptionWord,
} from './image-overlay-modal/types';

type CropEditorMode = 'crop' | 'brightness' | 'contrast' | 'saturation' | 'hue';

type CropAdjustments = {
  brightness: number;
  contrast: number;
  saturation: number;
  hue: number;
};

type CropShape = 'rectangle' | 'circle';

// Helper function to convert hex color to RGB
const hexToRgb = (hex: string) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
        result[3],
        16
      )}`
    : '0, 0, 0';
};

function roundedCanvasFromSource(
  source: HTMLCanvasElement,
  radiusPercent: number
): HTMLCanvasElement {
  if (!(radiusPercent > 0)) return source;

  const w = source.width;
  const h = source.height;
  const ctxRadius = Math.round(
    (Math.min(w, h) / 2) * Math.min(1, Math.max(0, radiusPercent / 100))
  );
  if (!(ctxRadius > 0)) return source;

  const out = document.createElement('canvas');
  out.width = w;
  out.height = h;
  const ctx = out.getContext('2d');
  if (!ctx) return source;

  const r = Math.min(ctxRadius, Math.floor(Math.min(w, h) / 2));

  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(r, 0);
  ctx.lineTo(w - r, 0);
  ctx.quadraticCurveTo(w, 0, w, r);
  ctx.lineTo(w, h - r);
  ctx.quadraticCurveTo(w, h, w - r, h);
  ctx.lineTo(r, h);
  ctx.quadraticCurveTo(0, h, 0, h - r);
  ctx.lineTo(0, r);
  ctx.quadraticCurveTo(0, 0, r, 0);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(source, 0, 0);
  ctx.restore();

  return out;
}

function circleCanvasFromSource(source: HTMLCanvasElement): HTMLCanvasElement {
  const w = source.width;
  const h = source.height;
  if (!(w > 0 && h > 0)) return source;

  const out = document.createElement('canvas');
  out.width = w;
  out.height = h;
  const ctx = out.getContext('2d');
  if (!ctx) return source;

  const r = Math.min(w, h) / 2;
  const cx = w / 2;
  const cy = h / 2;

  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(source, 0, 0);
  ctx.restore();

  return out;
}

function mergeRefs<T>(refs: Array<React.Ref<T> | undefined>) {
  return (value: T | null) => {
    for (const ref of refs) {
      if (!ref) continue;
      if (typeof ref === 'function') {
        ref(value);
      } else {
        try {
          (ref as React.MutableRefObject<T | null>).current = value;
        } catch {
          // ignore
        }
      }
    }
  };
}

const AdjustableImage = React.forwardRef<
  HTMLCanvasElement,
  {
    src?: string;
    className?: string;
    crossOrigin?: 'anonymous' | 'use-credentials' | boolean;
    brightness?: number;
    saturation?: number;
    hue?: number;
    contrast?: number;
    style?: React.CSSProperties;
  }
>(
  (
    {
      src,
      className,
      crossOrigin,
      brightness = 0,
      saturation = 0,
      hue = 0,
      contrast = 0,
      style,
    },
    ref
  ) => {
    const imageRef = useRef<HTMLImageElement | null>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);

    const drawImage = useCallback(() => {
      const image = imageRef.current;
      const canvas = canvasRef.current;
      if (!canvas || !image || !image.complete) return;

      const w = image.naturalWidth;
      const h = image.naturalHeight;
      if (!(w > 0 && h > 0)) return;

      const ctx = canvas.getContext('2d');
      canvas.width = w;
      canvas.height = h;
      if (!ctx) return;

      ctx.clearRect(0, 0, w, h);
      ctx.filter = [
        `brightness(${100 + brightness * 100}%)`,
        `contrast(${100 + contrast * 100}%)`,
        `saturate(${100 + saturation * 100}%)`,
        `hue-rotate(${hue * 360}deg)`,
      ].join(' ');
      ctx.drawImage(image, 0, 0, w, h);
    }, [brightness, contrast, saturation, hue]);

    useEffect(() => {
      if (!src) {
        imageRef.current = null;
        return;
      }

      const img = new Image();
      if (crossOrigin) {
        img.crossOrigin = crossOrigin === true ? 'anonymous' : crossOrigin;
      }
      img.onload = () => {
        imageRef.current = img;
        drawImage();
      };
      img.src = src;
      imageRef.current = img;

      // Attempt a draw in case it was cached.
      drawImage();

      return () => {
        if (imageRef.current === img) {
          imageRef.current = null;
        }
      };
    }, [drawImage, src, crossOrigin]);

    return (
      <>
        <canvas
          key={`${src || 'no-src'}-canvas`}
          ref={mergeRefs([ref, canvasRef])}
          className={className}
          style={style}
        />
      </>
    );
  }
);
AdjustableImage.displayName = 'AdjustableImage';

const AdjustableCropperBackground = React.forwardRef<
  HTMLCanvasElement,
  {
    className?: string;
    cropper: CropperRef;
    crossOrigin?: 'anonymous' | 'use-credentials' | boolean;
    brightness?: number;
    saturation?: number;
    hue?: number;
    contrast?: number;
  }
>(
  (
    {
      className,
      cropper,
      crossOrigin,
      brightness = 0,
      saturation = 0,
      hue = 0,
      contrast = 0,
    },
    ref
  ) => {
    const state = cropper.getState();
    const transitions = cropper.getTransitions();
    const image = cropper.getImage();
    const style =
      image && state ? getBackgroundStyle(image, state, transitions) : {};

    return (
      <AdjustableImage
        src={image?.src}
        crossOrigin={crossOrigin}
        brightness={brightness}
        saturation={saturation}
        hue={hue}
        contrast={contrast}
        ref={ref}
        className={className}
        style={style}
      />
    );
  }
);
AdjustableCropperBackground.displayName = 'AdjustableCropperBackground';

type OverlayAnimation =
  | 'none'
  | 'bounceIn'
  | 'spring'
  | 'fadeIn'
  | 'miniZoom'
  | 'zoomIn'
  | 'slideLeft'
  | 'slideRight'
  | 'slideUp';

interface ImageOverlayModalProps {
  isOpen: boolean;
  onClose: () => void;
  videoUrl: string;
  sceneId: number;
  onApply: (
    sceneId: number,
    overlayImage: File | null,
    overlayText: string | null,
    position: { x: number; y: number },
    size: { width: number; height: number },
    startTime: number,
    endTime: number,
    textStyling?: TextStyling,
    videoTintColor?: string | null,
    videoTintOpacity?: number,
    tintPosition?: { x: number; y: number },
    tintSize?: { width: number; height: number },
    tintInvert?: boolean,
    overlaySound?: string | null,
    overlayAnimation?: OverlayAnimation,
    gifLoop?: boolean
  ) => Promise<void>;
  isApplying?: boolean;
  handleTranscribeScene?: (
    sceneId: number,
    sceneData?: unknown,
    videoType?: 'original' | 'final',
    skipRefresh?: boolean,
    skipSound?: boolean
  ) => Promise<void>;
  onUpdateModalVideoUrl?: (videoUrl: string) => void;
}

export const ImageOverlayModal: React.FC<ImageOverlayModalProps> = ({
  isOpen,
  onClose,
  videoUrl,
  sceneId,
  onApply,
  isApplying = false,
  handleTranscribeScene,
  onUpdateModalVideoUrl,
}) => {
  const selectedOpenRouterModel = useAppStore(
    (state) => state.modelSelection.selectedModel
  );
  const previewButtonRef = useRef<HTMLButtonElement | null>(null);
  const pasteSinkRef = useRef<HTMLTextAreaElement | null>(null);
  const forceHandleOverlayPasteRef = useRef(false);
  const soundPreviewRef = useRef<HTMLAudioElement | null>(null);
  const [availableSounds, setAvailableSounds] = useState<
    { name: string; url: string }[]
  >([]);
  const [selectedSoundName, setSelectedSoundName] = useState<string | null>(
    null
  );
  const [overlayAnimation, setOverlayAnimation] =
    useState<OverlayAnimation>('miniZoom');
  const [overlayImage, setOverlayImage] = useState<File | null>(null);
  const [overlayImageUrl, setOverlayImageUrl] = useState<string | null>(null);
  const didAutoLoadSceneOverlayRef = useRef(false);
  const [overlayVideo, setOverlayVideo] = useState<File | null>(null);
  const [overlayVideoUrl, setOverlayVideoUrl] = useState<string | null>(null);
  const [isPastingOverlayFromClipboard, setIsPastingOverlayFromClipboard] =
    useState(false);
  const [cropperViewportPx, setCropperViewportPx] = useState<{
    width: number;
    height: number;
  } | null>(null);
  const [overlayPosition, setOverlayPosition] = useState({ x: 50, y: 50 }); // percentage
  const [overlaySize, setOverlaySize] = useState({ width: 40, height: 40 }); // percentage
  const [startTime, setStartTime] = useState(0);
  const [endTime, setEndTime] = useState(0);
  const [videoTintColor, setVideoTintColor] = useState<string | null>(null);
  const [currentVideoTime, setCurrentVideoTime] = useState(0);
  const [videoTintOpacity, setVideoTintOpacity] = useState(1);
  const [tintPosition, setTintPosition] = useState({ x: 50, y: 50 }); // percentage
  const [tintSize, setTintSize] = useState({ width: 100, height: 100 }); // percentage
  const [tintInvert, setTintInvert] = useState(false);
  const [isEditingTintArea, setIsEditingTintArea] = useState(false);
  const [isTintSectionOpen, setIsTintSectionOpen] = useState(false);
  const [isTextStylingSectionOpen, setIsTextStylingSectionOpen] =
    useState(false);
  const [isSoundSectionOpen, setIsSoundSectionOpen] = useState(false);
  const [isAnimationSectionOpen, setIsAnimationSectionOpen] = useState(false);

  const animationLabel = useMemo(() => {
    const labels: Record<OverlayAnimation, string> = {
      none: 'None',
      bounceIn: 'Bounce In',
      spring: 'Spring',
      fadeIn: 'Fade In',
      miniZoom: 'Mini Zoom',
      zoomIn: 'Zoom In',
      slideLeft: 'Slide Left',
      slideRight: 'Slide Right',
      slideUp: 'Slide Up',
    };
    return labels[overlayAnimation] ?? overlayAnimation;
  }, [overlayAnimation]);
  const tintPalette = useMemo(
    () => [
      '#000000',
      '#FFFFFF',
      '#DDC57A',
      '#00FF00',
      '#0000FF',
      '#FFFF00',
      '#FF00FF',
      '#00FFFF',
      '#FFA500',
    ],
    []
  );
  const [, setIsDragging] = useState(false);
  const [, setIsResizing] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isPreviewLoading, setIsPreviewLoading] = useState(false);
  const [isGeneratingScenePrompt, setIsGeneratingScenePrompt] = useState(false);
  const [scenePromptStatus, setScenePromptStatus] = useState<string | null>(
    null
  );
  const [isGeneratingSceneImage, setIsGeneratingSceneImage] = useState(false);
  const [sceneImageStatus, setSceneImageStatus] = useState<string | null>(null);
  const [isUpscalingSceneImage, setIsUpscalingSceneImage] = useState(false);
  const [sceneUpscaleStatus, setSceneUpscaleStatus] = useState<string | null>(
    null
  );
  const [transcriptionWords, setTranscriptionWords] = useState<
    TranscriptionWord[] | null
  >(null);
  const [selectedWordText, setSelectedWordText] = useState<string | null>(null);
  const [customText, setCustomText] = useState<string>('');
  const [textOverlayPosition, setTextOverlayPosition] = useState({
    x: 50,
    y: 50,
  }); // percentage

  useEffect(() => {
    if (!isOpen) return;
    let cancelled = false;
    (async () => {
      try {
        const res = await fetch('/api/list-sounds');
        const data = (await res.json()) as {
          sounds?: { name: string; url: string }[];
        };
        if (cancelled) return;
        setAvailableSounds(Array.isArray(data.sounds) ? data.sounds : []);
      } catch {
        if (cancelled) return;
        setAvailableSounds([]);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [isOpen]);

  const fetchOverlayFileFromUrl = useCallback(async (url: string) => {
    const res = await fetch(`/api/fetch-image?url=${encodeURIComponent(url)}`);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      throw new Error(`Failed to fetch overlay image (${res.status}) ${t}`);
    }

    const contentType = res.headers.get('content-type') || '';
    const blob = await res.blob();
    const type = blob.type || contentType || 'image/png';

    const ext = type.includes('gif')
      ? 'gif'
      : type.includes('jpeg') || type.includes('jpg')
      ? 'jpg'
      : type.includes('webp')
      ? 'webp'
      : 'png';

    return new File([blob], `overlay_${Date.now()}.${ext}`, { type });
  }, []);

  const loadOverlayFromRemoteUrl = useCallback(
    async (url: string) => {
      const file = await fetchOverlayFileFromUrl(url);

      // Use a local blob URL to avoid CORS-tainted canvases (cropper relies on canvas).
      const localUrl = URL.createObjectURL(file);

      setOverlayImage(file);
      setOverlayImageUrl(localUrl);

      // Clear text overlay when adding an image overlay.
      setSelectedWordText(null);
      setCustomText('');

      // Best-effort: update actual dimensions and default sizing.
      const img = new Image();
      img.onload = () => {
        setActualImageDimensions({ width: img.width, height: img.height });

        // We may not know the video's natural dimensions yet; use the same
        // fallback defaults as elsewhere to derive a reasonable initial % size.
        const videoWidth = 1920;
        const videoHeight = 1080;
        const widthPercent = (img.width / videoWidth) * 100;
        const heightPercent = (img.height / videoHeight) * 100;
        setOverlaySize({
          width: Math.min(widthPercent, 100),
          height: Math.min(heightPercent, 100),
        });
      };
      img.src = localUrl;
    },
    [fetchOverlayFileFromUrl, setOverlaySize]
  );

  // On open, prefer loading Upscaled Image for Scene (7095) if present.
  useEffect(() => {
    if (!isOpen || !sceneId) return;
    if (didAutoLoadSceneOverlayRef.current) return;
    if (overlayImage || overlayImageUrl) return;

    let cancelled = false;
    (async () => {
      try {
        const sceneData = await getSceneById(sceneId);
        if (cancelled) return;

        const upscaled =
          typeof sceneData?.['field_7095'] === 'string'
            ? sceneData['field_7095']
            : '';
        const base =
          typeof sceneData?.['field_7094'] === 'string'
            ? sceneData['field_7094']
            : '';

        const preferred = upscaled.trim() ? upscaled : base.trim() ? base : '';
        if (!preferred) return;

        didAutoLoadSceneOverlayRef.current = true;
        await loadOverlayFromRemoteUrl(preferred);
      } catch {
        // ignore best-effort load
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [
    isOpen,
    sceneId,
    overlayImage,
    overlayImageUrl,
    loadOverlayFromRemoteUrl,
  ]);

  useEffect(() => {
    if (!isOpen) return;
    didAutoLoadSceneOverlayRef.current = false;
  }, [isOpen, sceneId]);

  const playOverlaySoundPreview = useCallback(
    (soundName: string | null) => {
      if (!soundName) return;

      const match = availableSounds.find((s) => s.name === soundName);
      const url = match?.url || `/sounds/${encodeURIComponent(soundName)}`;

      try {
        if (soundPreviewRef.current) {
          try {
            soundPreviewRef.current.pause();
            soundPreviewRef.current.currentTime = 0;
          } catch {
            // ignore
          }
        }

        const audio = new Audio(url);
        soundPreviewRef.current = audio;
        audio.play().catch(() => {
          // ignore autoplay/user-gesture restrictions
        });
      } catch {
        // ignore
      }
    },
    [availableSounds]
  );

  const cycleOverlaySound = useCallback(() => {
    const ordered: (string | null)[] = [
      null,
      ...availableSounds.map((s) => s.name),
    ];
    if (ordered.length <= 1) return;

    const currentIndex = ordered.findIndex((n) => n === selectedSoundName);
    const nextIndex =
      currentIndex >= 0 ? (currentIndex + 1) % ordered.length : 0;
    const next = ordered[nextIndex] ?? null;
    setSelectedSoundName(next);
    playOverlaySoundPreview(next);
  }, [availableSounds, selectedSoundName, playOverlaySoundPreview]);

  // Timer countdown effect
  useEffect(() => {
    if (!isOpen) {
      setTimerSeconds(120); // Reset timer when modal closes
      return;
    }

    const interval = setInterval(() => {
      setTimerSeconds((prev) => {
        if (prev <= 1) {
          // Timer reached 0, play sound
          const audio = new Audio('/sounds/pop.wav');
          audio.play().catch(() => {
            // Ignore audio play errors
          });
          clearInterval(interval);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [isOpen]);

  const [textOverlaySize, setTextOverlaySize] = useState({
    width: 100,
    height: 100,
  }); // percentage
  const [textStyling, setTextStyling] = useState<TextStyling>(() => {
    // Load default styling from localStorage, or use fallback defaults
    const saved = localStorage.getItem('defaultTextStyling');
    return saved
      ? JSON.parse(saved)
      : {
          fontColor: '#ffffff',
          borderWidth: 3,
          borderColor: '#000000',
          shadowX: 8,
          shadowY: 8,
          shadowColor: '#000000',
          shadowOpacity: 0.9,
          fontFamily: 'Helvetica',
          // Background (box) settings for text overlay
          bgColor: '#000000',
          bgOpacity: 0.65,
          bgSize: 8, // px padding for background around text
        };
  });
  // Saved text styling presets, persisted in localStorage
  const [savedTextStyles, setSavedTextStyles] = useState<
    { name: string; style: TextStyling }[]
  >([]);
  const [isFontLoaded, setIsFontLoaded] = useState<boolean>(false);
  const [showFontPreview, setShowFontPreview] = useState<boolean>(false);
  const [timerSeconds, setTimerSeconds] = useState(120); // 2 minutes countdown

  // Load saved styles from localStorage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem('savedTextStyles');
      if (stored) {
        console.log('Loading savedTextStyles from localStorage:', stored);
        const parsed = JSON.parse(stored) as {
          name: string;
          style: TextStyling;
        }[];
        setSavedTextStyles(parsed);
      }
    } catch (e) {
      console.error('Failed to load saved text styles:', e);
    }
  }, []);

  // Check whether the selected font family is loaded by the browser for live preview
  useEffect(() => {
    const family = textStyling.fontFamily;
    if (!family || typeof document === 'undefined' || !document.fonts) {
      setIsFontLoaded(false);
      return;
    }

    // Check if the font is available already
    (async () => {
      try {
        // Try to load a tiny variation and check if loaded
        await document.fonts.load(`12px "${family}"`);
        const loaded = document.fonts.check(`12px "${family}"`);
        setIsFontLoaded(loaded);
      } catch {
        setIsFontLoaded(false);
      }
    })();
  }, [textStyling.fontFamily]);

  // Build a list of fonts from the JSON mapping and fall back to a small default set
  const availableFontFamilies = useMemo(() => {
    const mapping = ffmpegFonts as Record<string, string>;
    const keys = Object.keys(mapping || {}).filter(
      (k) => k !== 'user_fonts_dir'
    );
    if (keys.length > 0) return keys.sort();
    // fallback:
    return ['Helvetica', 'Arial', 'Courier', 'Times', 'Menlo'];
  }, []);

  // Previously we wrote savedTextStyles on every state change, which could
  // overwrite loaded values on mount due to timing; we now only write to
  // localStorage explicitly when saving/deleting presets so we avoid race conditions.

  const saveCurrentTextStyle = useCallback(() => {
    const name = prompt('Enter a name for this text style preset');
    if (!name) return;
    // avoid duplicates
    if (savedTextStyles.some((s) => s.name === name)) {
      alert('A preset with that name already exists');
      return;
    }
    console.log('Saving preset', name, textStyling);
    setSavedTextStyles((prev) => {
      const next = [...prev, { name, style: textStyling }];
      try {
        localStorage.setItem('savedTextStyles', JSON.stringify(next));
        console.log('Saved preset to localStorage', next);
      } catch (e) {
        console.error('Failed to persist savedTextStyles during save', e);
      }
      return next;
    });
  }, [savedTextStyles, textStyling]);

  const applySavedTextStyle = useCallback(
    (preset: { name: string; style: TextStyling }) => {
      setTextStyling(preset.style);
    },
    []
  );

  const cycleNextTextPreset = useCallback(() => {
    if (!savedTextStyles || savedTextStyles.length === 0) return;

    const stableStringify = (value: unknown): string => {
      if (value === null) return 'null';
      const t = typeof value;
      if (t === 'string') return JSON.stringify(value);
      if (t === 'number' || t === 'boolean') return String(value);
      if (Array.isArray(value)) {
        return `[${value.map(stableStringify).join(',')}]`;
      }
      if (t === 'object') {
        const obj = value as Record<string, unknown>;
        const keys = Object.keys(obj).sort();
        return `{${keys
          .map((k) => `${JSON.stringify(k)}:${stableStringify(obj[k])}`)
          .join(',')}}`;
      }
      return JSON.stringify(String(value));
    };

    const currentKey = stableStringify(textStyling);
    const currentIndex = savedTextStyles.findIndex(
      (p) => stableStringify(p.style) === currentKey
    );
    const nextIndex =
      currentIndex >= 0 ? (currentIndex + 1) % savedTextStyles.length : 0;

    applySavedTextStyle(savedTextStyles[nextIndex]);
  }, [applySavedTextStyle, savedTextStyles, textStyling]);

  const deleteSavedTextStyle = useCallback((name: string) => {
    if (!confirm(`Delete preset ${name}?`)) return;
    setSavedTextStyles((prev) => {
      const next = prev.filter((s) => s.name !== name);
      try {
        localStorage.setItem('savedTextStyles', JSON.stringify(next));
        console.log('Updated localStorage after delete', next);
      } catch (e) {
        console.error('Failed to persist savedTextStyles during delete', e);
      }
      return next;
    });
  }, []);
  const [, setIsDraggingText] = useState(false);
  const [, setIsResizingText] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [refetchTrigger, setRefetchTrigger] = useState(0);
  const [containerRect, setContainerRect] = useState<{
    width: number;
    height: number;
  } | null>(null);
  const [videoToCssScale, setVideoToCssScale] = useState(1);

  // Cropping state
  const [isCropping, setIsCropping] = useState(false);
  const cropperRef = useRef<CropperRef>(null);
  const [cropperModalKey, setCropperModalKey] = useState(0);
  const didInitCropCoordinatesRef = useRef<string | null>(null);
  const [cropBorderRadius, setCropBorderRadius] = useState(0);
  const [cropShape, setCropShape] = useState<CropShape>('rectangle');
  const [cropRotationDegrees, setCropRotationDegrees] = useState(0);

  // Video editing state
  const [isVideoEditModalOpen, setIsVideoEditModalOpen] = useState(false);

  const [cropEditorMode, setCropEditorMode] = useState<CropEditorMode>('crop');
  const [cropAdjustments, setCropAdjustments] = useState<CropAdjustments>({
    brightness: 0,
    contrast: 0,
    saturation: 0,
    hue: 0,
  });
  const [isCropStencilLocked, setIsCropStencilLocked] = useState(true);

  const isGifOverlay = overlayImage?.type === 'image/gif';
  const [loopGif, setLoopGif] = useState(false);

  // Default: if a GIF is selected, loop is ON.
  // Only set this when the selected file changes, so it won't override the
  // user's checkbox toggle while keeping the same GIF selected.
  useEffect(() => {
    if (!overlayImage) {
      setLoopGif(false);
      return;
    }
    if (overlayImage.type === 'image/gif') {
      setLoopGif(true);
    } else {
      setLoopGif(false);
    }
  }, [overlayImage]);

  const setCropRotationAbsolute = useCallback((nextDegrees: number) => {
    const next = Math.max(-180, Math.min(180, Math.round(nextDegrees)));
    const cropper = cropperRef.current;
    if (!cropper) {
      setCropRotationDegrees(next);
      return;
    }

    const current = cropper.getTransforms()?.rotate ?? 0;
    cropper.rotateImage(next - current);
    setCropRotationDegrees(next);
  }, []);

  // Safari needs a polyfill for CanvasRenderingContext2D.filter.
  useEffect(() => {
    if (typeof window === 'undefined') return;
    void import('context-filter-polyfill').catch(() => {
      // ignore
    });
  }, []);

  // Border radius isn't reliably supported for GIF output; keep it disabled.
  useEffect(() => {
    if (isGifOverlay) {
      setCropBorderRadius(0);
      setCropShape('rectangle');
      setCropRotationDegrees(0);
      setCropEditorMode('crop');
      setCropAdjustments({
        brightness: 0,
        contrast: 0,
        saturation: 0,
        hue: 0,
      });
    }
  }, [isGifOverlay]);

  useEffect(() => {
    if (cropShape === 'circle') {
      setCropBorderRadius(0);
    }
  }, [cropShape]);

  // Actual image dimensions in pixels
  const [actualImageDimensions, setActualImageDimensions] = useState<{
    width: number;
    height: number;
  } | null>(null);

  // Store the original video URL when the modal opens
  const [originalVideoUrl, setOriginalVideoUrl] = useState<string | null>(null);
  const [previousVideoUrl, setPreviousVideoUrl] = useState<string | null>(null);

  const videoRef = useRef<HTMLVideoElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null!);
  const videoFileInputRef = useRef<HTMLInputElement>(null!);
  const previewVideoRef = useRef<HTMLVideoElement>(null);

  const [previewDurationSeconds, setPreviewDurationSeconds] = useState(0);
  const [previewCurrentTimeSeconds, setPreviewCurrentTimeSeconds] = useState(0);
  const [isPreviewPaused, setIsPreviewPaused] = useState(true);

  useEffect(() => {
    if (!previewUrl) return;
    const video = previewVideoRef.current;
    if (!video) return;

    const updateTime = () =>
      setPreviewCurrentTimeSeconds(video.currentTime || 0);
    const updateDuration = () =>
      setPreviewDurationSeconds(
        Number.isFinite(video.duration) ? Math.max(0, video.duration) : 0
      );
    const updatePaused = () => setIsPreviewPaused(video.paused);

    updateDuration();
    updateTime();
    updatePaused();

    video.addEventListener('timeupdate', updateTime);
    video.addEventListener('durationchange', updateDuration);
    video.addEventListener('loadedmetadata', updateDuration);
    video.addEventListener('play', updatePaused);
    video.addEventListener('pause', updatePaused);

    return () => {
      video.removeEventListener('timeupdate', updateTime);
      video.removeEventListener('durationchange', updateDuration);
      video.removeEventListener('loadedmetadata', updateDuration);
      video.removeEventListener('play', updatePaused);
      video.removeEventListener('pause', updatePaused);
    };
  }, [previewUrl]);

  useEffect(() => {
    if (!isOpen) return;
    const video = videoRef.current;
    if (!video) return;

    const update = () => setCurrentVideoTime(video.currentTime || 0);
    video.addEventListener('timeupdate', update);
    video.addEventListener('seeked', update);
    update();

    return () => {
      video.removeEventListener('timeupdate', update);
      video.removeEventListener('seeked', update);
    };
  }, [isOpen, originalVideoUrl]);

  const isTintActive =
    !!videoTintColor &&
    Number.isFinite(startTime) &&
    Number.isFinite(endTime) &&
    currentVideoTime >= startTime &&
    currentVideoTime <= endTime;

  const shouldShowTintOverlay =
    !!videoTintColor && (isTintActive || isEditingTintArea);

  const tintRect = useMemo(() => {
    const clampPct = (v: number) => Math.max(0, Math.min(100, v));
    const safeW = Math.max(0, Math.min(100, tintSize.width));
    const safeH = Math.max(0, Math.min(100, tintSize.height));
    const left = clampPct(tintPosition.x - safeW / 2);
    const top = clampPct(tintPosition.y - safeH / 2);
    const right = clampPct(tintPosition.x + safeW / 2);
    const bottom = clampPct(tintPosition.y + safeH / 2);
    return {
      left,
      top,
      right,
      bottom,
      width: Math.max(0, right - left),
      height: Math.max(0, bottom - top),
    };
  }, [tintPosition, tintSize]);

  const clamp01 = useCallback((v: number) => Math.max(0, Math.min(1, v)), []);

  // Keep a scale factor so CSS preview sizes (px) match FFmpeg drawtext sizes (video px).
  // Example: borderw=3 in FFmpeg should appear as ~3px on the source video, which is
  // borderw * (displayedVideoPx / sourceVideoPx) in the browser preview.
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const rect = containerRect ?? video.getBoundingClientRect();
    if (!rect?.width || !rect?.height) return;
    if (!video.videoWidth || !video.videoHeight) return;

    const scaleX = rect.width / video.videoWidth;
    const scaleY = rect.height / video.videoHeight;
    const next = Math.min(scaleX, scaleY);
    if (Number.isFinite(next) && next > 0) setVideoToCssScale(next);
  }, [containerRect, originalVideoUrl]);

  const getVideoContentRect = useCallback(() => {
    const video = videoRef.current;
    if (!video) return null;

    // Use the video element's rect for overlay positioning
    const rect = video.getBoundingClientRect();
    return rect;
  }, []);

  const getVideoNaturalDimensions = useCallback(() => {
    const video = videoRef.current;
    const vw = video?.videoWidth;
    const vh = video?.videoHeight;
    return {
      videoWidth: typeof vw === 'number' && vw > 0 ? vw : 1920,
      videoHeight: typeof vh === 'number' && vh > 0 ? vh : 1080,
    };
  }, []);

  const setOverlaySizeFromPixels = useCallback(
    (w: number, h: number) => {
      const { videoWidth, videoHeight } = getVideoNaturalDimensions();
      const widthPercent = (w / videoWidth) * 100;
      const heightPercent = (h / videoHeight) * 100;
      setOverlaySize({
        width: Math.min(widthPercent, 100),
        height: Math.min(heightPercent, 100),
      });
    },
    [getVideoNaturalDimensions, setOverlaySize]
  );

  const handleOverlayWheelZoom = useCallback(
    (e: React.WheelEvent) => {
      // Ignore browser pinch-zoom (trackpad pinch typically sets ctrlKey=true on macOS).
      if (e.ctrlKey) return;

      e.preventDefault();
      e.stopPropagation();

      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      setOverlaySize((prev) => ({
        width: Math.min(100, Math.max(5, prev.width * factor)),
        height: Math.min(100, Math.max(5, prev.height * factor)),
      }));
    },
    [setOverlaySize]
  );

  const handleTextOverlayWheelZoom = useCallback(
    (e: React.WheelEvent) => {
      if (e.ctrlKey) return;

      e.preventDefault();
      e.stopPropagation();

      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      setTextOverlaySize((prev) => ({
        width: Math.min(100, Math.max(5, prev.width * factor)),
        height: Math.min(100, Math.max(5, prev.height * factor)),
      }));
    },
    [setTextOverlaySize]
  );

  const ensureOverlayImageDimensions = useCallback(async () => {
    if (actualImageDimensions) return actualImageDimensions;
    if (!overlayImageUrl) return null;

    const img = new Image();
    img.src = overlayImageUrl;
    try {
      // decode() is more reliable than onload timing for some images
      if (typeof img.decode === 'function') {
        await img.decode();
      } else {
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = () => reject(new Error('Failed to load image'));
        });
      }
    } catch {
      return null;
    }

    if (!(img.width > 0 && img.height > 0)) return null;
    const dims = { width: img.width, height: img.height };
    setActualImageDimensions(dims);
    return dims;
  }, [actualImageDimensions, overlayImageUrl]);

  const handleImageUpload = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file && file.type.startsWith('image/')) {
        setOverlayImage(file);
        const url = URL.createObjectURL(file);
        setOverlayImageUrl(url);
        // Clear text overlay when adding image
        setSelectedWordText(null);
        setCustomText('');

        const img = new Image();
        img.onload = () => {
          setActualImageDimensions({ width: img.width, height: img.height });
          setOverlaySizeFromPixels(img.width, img.height);
        };
        img.src = url;
      }
    },
    [setOverlaySizeFromPixels]
  );

  const handleVideoUpload = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file && file.type.startsWith('video/')) {
        setOverlayVideo(file);
        const url = URL.createObjectURL(file);
        setOverlayVideoUrl(url);
        // Open video editing modal
        setIsVideoEditModalOpen(true);
      }
    },
    []
  );

  const handleRemoveImage = useCallback(() => {
    setOverlayImage(null);
    setOverlayImageUrl(null);
    // Prevent the auto-load effect from re-injecting the scene image
    // after the user explicitly removed it in this modal session.
    didAutoLoadSceneOverlayRef.current = true;
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, []);

  const handleScreenshot = useCallback(() => {
    const video = videoRef.current;
    if (!video) return;

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      canvas.toBlob((blob) => {
        if (blob) {
          const file = new File([blob], 'screenshot.png', {
            type: 'image/png',
          });
          setOverlayImage(file);
          const url = URL.createObjectURL(file);
          setOverlayImageUrl(url);
          // Clear text overlay when adding image
          setSelectedWordText(null);
          setCustomText('');

          setActualImageDimensions({
            width: canvas.width,
            height: canvas.height,
          });
          setOverlaySizeFromPixels(canvas.width, canvas.height);
        }
      }, 'image/png');
    }
  }, [setOverlaySizeFromPixels]);

  const handleCopyOverlayImageToClipboard = useCallback(async () => {
    if (!overlayImage) return;

    try {
      const clipboard = navigator.clipboard;
      type ClipboardItemConstructor = new (
        items: Record<string, Blob>
      ) => ClipboardItem;
      const ClipboardItemCtor = (
        window as unknown as {
          ClipboardItem?: ClipboardItemConstructor;
        }
      ).ClipboardItem;

      if (!clipboard?.write || !ClipboardItemCtor) {
        alert('Copying images to clipboard is not supported in this browser.');
        return;
      }

      const mime = overlayImage.type || 'image/png';
      await clipboard.write([
        new ClipboardItemCtor({
          [mime]: overlayImage,
        }),
      ]);
    } catch (e) {
      console.error('Failed to copy overlay image to clipboard:', e);
      alert(
        'Failed to copy image to clipboard. Your browser may be blocking clipboard access.'
      );
    }
  }, [overlayImage]);

  const setOverlayFromFile = useCallback(
    (file: File) => {
      setOverlayImage(file);
      const url = URL.createObjectURL(file);
      setOverlayImageUrl(url);

      // Clear text overlay when adding image
      setSelectedWordText(null);
      setCustomText('');

      // Calculate overlay size similarly to upload/screenshot
      const img = new Image();
      img.onload = () => {
        setActualImageDimensions({ width: img.width, height: img.height });
        setOverlaySizeFromPixels(img.width, img.height);
      };
      img.src = url;
    },
    [setOverlaySizeFromPixels]
  );

  // Allow Cmd+V / paste to apply an overlay image without triggering the
  // async Clipboard API (which causes Safari/iOS to show a system "Paste"
  // confirmation bubble that requires an extra click).
  useEffect(() => {
    if (!isOpen) return;

    const extractFirstUrl = (text: string): string | null => {
      const trimmed = text.trim();
      if (!trimmed) return null;
      if (trimmed.startsWith('data:image/')) return trimmed;
      const m = trimmed.match(/https?:\/\/[\w\W]*?/i);
      if (!m) return null;
      // Tighten to the first URL-like token
      const token = trimmed.match(/https?:\/\/[^\s"'<>]+/i);
      return token ? token[0] : null;
    };

    const fetchImageAsFile = async (url: string): Promise<File | null> => {
      const res = await fetch(
        `/api/fetch-image?url=${encodeURIComponent(url)}`
      );
      if (!res.ok) return null;
      const blob = await res.blob();
      if (blob.type && !blob.type.startsWith('image/')) return null;
      const type = blob.type || 'image/png';
      const ext = type.split('/')[1] || 'png';
      return new File([blob], `pasted-url-image.${ext}`, { type });
    };

    const handlePaste = (event: ClipboardEvent) => {
      const forceHandle = forceHandleOverlayPasteRef.current;
      if (forceHandle) {
        forceHandleOverlayPasteRef.current = false;
      }

      const finishLoadingIfNeeded = () => {
        if (forceHandle || isPastingOverlayFromClipboard) {
          setIsPastingOverlayFromClipboard(false);
        }
      };

      // If an input or editable element is focused, allow normal typing paste,
      // unless Ctrl+1 explicitly requested an overlay paste.
      const target = event.target as Element | null;
      const targetIsPasteSink =
        target instanceof HTMLTextAreaElement &&
        target === pasteSinkRef.current;

      if (
        !forceHandle &&
        !targetIsPasteSink &&
        (target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable))
      ) {
        return;
      }

      const data = event.clipboardData;
      if (!data) return;

      // 1) Prefer direct image files
      const items = Array.from(data.items || []);
      const imageItem = items.find(
        (it) => it.kind === 'file' && it.type.startsWith('image/')
      );
      if (imageItem) {
        const file = imageItem.getAsFile();
        if (!file) return;
        event.preventDefault();
        setOverlayFromFile(file);
        finishLoadingIfNeeded();
        return;
      }

      // 2) Try HTML <img src>
      const html = data.getData('text/html');
      if (html) {
        const srcMatch = html.match(/<img[^>]+src=["']([^"']+)["']/i);
        const src = srcMatch?.[1] ? extractFirstUrl(srcMatch[1]) : null;
        if (src) {
          event.preventDefault();
          if (src.startsWith('data:image/')) {
            void fetch(src)
              .then((r) => r.blob())
              .then((blob) => {
                const type = blob.type || 'image/png';
                const ext = type.split('/')[1] || 'png';
                setOverlayFromFile(
                  new File([blob], `pasted-data-image.${ext}`, { type })
                );
              })
              .finally(finishLoadingIfNeeded)
              .catch(() => {
                // ignore
              });
            return;
          }

          void fetchImageAsFile(src)
            .then((file) => {
              if (file) setOverlayFromFile(file);
            })
            .finally(finishLoadingIfNeeded)
            .catch(() => {
              // ignore
            });
          return;
        }
      }

      // 3) Try plain text URL
      const text = data.getData('text/plain');
      const maybeUrl = text ? extractFirstUrl(text) : null;
      if (!maybeUrl) return;

      event.preventDefault();
      if (maybeUrl.startsWith('data:image/')) {
        void fetch(maybeUrl)
          .then((r) => r.blob())
          .then((blob) => {
            const type = blob.type || 'image/png';
            const ext = type.split('/')[1] || 'png';
            setOverlayFromFile(
              new File([blob], `pasted-data-image.${ext}`, { type })
            );
          })
          .finally(finishLoadingIfNeeded)
          .catch(() => {
            // ignore
          });
        return;
      }

      void fetchImageAsFile(maybeUrl)
        .then((file) => {
          if (file) setOverlayFromFile(file);
        })
        .finally(finishLoadingIfNeeded)
        .catch(() => {
          // ignore
        });

      // If we got here, we kicked off an async path and will finish later.
    };

    document.addEventListener('paste', handlePaste, { capture: true });
    return () => {
      document.removeEventListener('paste', handlePaste, { capture: true });
    };
  }, [isOpen, setOverlayFromFile, isPastingOverlayFromClipboard]);

  const openCropModal = useCallback(() => {
    if (!overlayImageUrl) return;
    setCropBorderRadius(0);
    setCropEditorMode('crop');
    setCropShape('rectangle');
    setCropRotationDegrees(0);
    setIsCropStencilLocked(true);
    setCropAdjustments({
      brightness: 0,
      contrast: 0,
      saturation: 0,
      hue: 0,
    });
    setCropperModalKey((k) => k + 1);
    setCropperViewportPx(null);
    didInitCropCoordinatesRef.current = null;
    setIsCropping(true);
  }, [overlayImageUrl]);

  useEffect(() => {
    if (!isCropping) {
      setCropperViewportPx(null);
      return;
    }

    let cancelled = false;
    void (async () => {
      const dims = await ensureOverlayImageDimensions();
      if (cancelled || !dims) return;

      // Fit the cropper to the image, within the modal and viewport.
      const maxWidth = Math.min(
        // window width minus modal margins (mx-4) and padding (p-6)
        Math.max(240, window.innerWidth - 80),
        // max-w-4xl (896px) minus p-6 left+right (48px)
        848
      );
      const maxHeight = Math.max(200, Math.floor(window.innerHeight * 0.5));

      const scale = Math.min(maxWidth / dims.width, maxHeight / dims.height, 1);
      const width = Math.max(1, Math.round(dims.width * scale));
      const height = Math.max(1, Math.round(dims.height * scale));
      setCropperViewportPx({ width, height });
    })();

    return () => {
      cancelled = true;
    };
  }, [isCropping, ensureOverlayImageDimensions]);

  const handlePasteOverlayImageFromClipboard = useCallback(async () => {
    setIsPastingOverlayFromClipboard(true);
    try {
      const clipboard = navigator.clipboard;
      if (!clipboard) {
        alert('Clipboard is not available in this browser.');
        return;
      }

      const extractFirstUrl = (text: string): string | null => {
        const trimmed = text.trim();
        if (!trimmed) return null;

        // Handle data URLs
        if (trimmed.startsWith('data:image/')) return trimmed;

        // Extract first http(s) URL from any text blob
        const m = trimmed.match(/https?:\/\/[^\s"'<>]+/i);
        return m ? m[0] : null;
      };

      const fetchImageAsFile = async (url: string): Promise<File | null> => {
        const res = await fetch(
          `/api/fetch-image?url=${encodeURIComponent(url)}`
        );
        if (!res.ok) {
          // Try to surface server error JSON if present
          let message = `Failed to fetch image URL (${res.status})`;
          try {
            const j = (await res.json()) as { error?: string };
            if (j?.error) message = j.error;
          } catch {
            // ignore
          }

          // If the URL resolves but is not an image (e.g. video/mp4), silently ignore.
          if (/did not return an image|content-type/i.test(message)) {
            return null;
          }

          throw new Error(message);
        }

        const blob = await res.blob();
        if (blob.type && !blob.type.startsWith('image/')) {
          return null;
        }
        const type = blob.type || 'image/png';
        const ext = type.split('/')[1] || 'png';
        return new File([blob], `pasted-url-image.${ext}`, { type });
      };

      // Prefer text paste first (URL/data URL). On Safari/iOS this usually yields
      // a single system “Paste” confirmation, instead of multiple prompts.
      const tryReadTextUrl = async (): Promise<string | null> => {
        if (!clipboard.readText) return null;
        try {
          const text = await clipboard.readText();
          return text ? extractFirstUrl(text) : null;
        } catch {
          return null;
        }
      };

      const maybeUrlFromText = await tryReadTextUrl();
      if (maybeUrlFromText) {
        if (maybeUrlFromText.startsWith('data:image/')) {
          const blob = await (await fetch(maybeUrlFromText)).blob();
          const type = blob.type || 'image/png';
          const ext = type.split('/')[1] || 'png';
          setOverlayFromFile(
            new File([blob], `pasted-data-image.${ext}`, { type })
          );
          return;
        }

        // http(s) URL
        const file = await fetchImageAsFile(maybeUrlFromText);
        if (!file) return;
        setOverlayFromFile(file);
        return;
      }

      // 1) Prefer true clipboard image blobs when available
      if (clipboard?.read) {
        const items = await clipboard.read();
        for (const item of items) {
          const t = (item.types || []).find((x) => x.startsWith('image/'));
          if (!t) continue;
          const imageBlob = await item.getType(t);
          const ext = t.split('/')[1] || 'png';
          setOverlayFromFile(
            new File([imageBlob], `clipboard-image.${ext}`, { type: t })
          );
          return;
        }

        // 2) If clipboard includes HTML, try extracting <img src="...">
        for (const item of items) {
          if (!item.types?.includes('text/html')) continue;
          const htmlBlob = await item.getType('text/html');
          const html = await htmlBlob.text();
          const srcMatch = html.match(/<img[^>]+src=["']([^"']+)["']/i);
          const src = srcMatch?.[1] ? extractFirstUrl(srcMatch[1]) : null;
          if (src) {
            const file = src.startsWith('data:image/')
              ? (() => {
                  return fetch(src)
                    .then((r) => r.blob())
                    .then((blob) => {
                      const type = blob.type || 'image/png';
                      const ext = type.split('/')[1] || 'png';
                      return new File([blob], `pasted-html-image.${ext}`, {
                        type,
                      });
                    });
                })()
              : fetchImageAsFile(src);
            const resolved = await file;
            if (!resolved) return;
            setOverlayFromFile(resolved);
            return;
          }
        }
      }

      // 3) Fall back to manual URL paste
      const manual = prompt('Paste an image URL:');
      const manualUrl = manual ? extractFirstUrl(manual) : null;
      if (!manualUrl) {
        alert('No image URL provided.');
        return;
      }

      if (manualUrl.startsWith('data:image/')) {
        const blob = await (await fetch(manualUrl)).blob();
        const type = blob.type || 'image/png';
        const ext = type.split('/')[1] || 'png';
        setOverlayFromFile(
          new File([blob], `pasted-data-image.${ext}`, { type })
        );
        return;
      }

      const file = await fetchImageAsFile(manualUrl);
      if (!file) return;
      setOverlayFromFile(file);
      return;
    } catch (e) {
      // Avoid noisy console errors; show a user-facing message only.
      alert(
        'Failed to paste image from clipboard. Your browser may be blocking clipboard access.'
      );
    } finally {
      setIsPastingOverlayFromClipboard(false);
    }
  }, [setOverlayFromFile]);

  const applyCrop = useCallback(async () => {
    console.log('applyCrop called');
    if (!cropperRef.current || !overlayImageUrl) {
      console.log('Missing cropperRef.current or overlayImageUrl');
      return;
    }

    const coordinates = cropperRef.current.getCoordinates();
    const canvas = cropperRef.current.getCanvas();

    console.log('Coordinates:', coordinates);
    console.log('Canvas:', canvas);

    if (!coordinates || !canvas) {
      console.log('Missing coordinates or canvas');
      return;
    }

    const applyCroppedFile = (croppedFile: File, w: number, h: number) => {
      const croppedUrl = URL.createObjectURL(croppedFile);

      setOverlayImage(croppedFile);
      setOverlayImageUrl(croppedUrl);

      setActualImageDimensions({ width: w, height: h });

      // Auto-reset overlay size to cropped image natural size
      setOverlayPosition({ x: 50, y: 50 });
      setOverlaySizeFromPixels(w, h);

      setIsCropping(false);
      console.log('Crop applied successfully');
    };

    // If the overlay is an animated GIF, canvas cropping will freeze it.
    // For GIFs, crop server-side with FFmpeg to preserve animation.
    if (overlayImage?.type === 'image/gif') {
      const left = Math.round(coordinates.left);
      const top = Math.round(coordinates.top);
      const width = Math.round(coordinates.width);
      const height = Math.round(coordinates.height);

      const form = new FormData();
      form.append('image', overlayImage);
      form.append('left', String(Math.max(0, left)));
      form.append('top', String(Math.max(0, top)));
      form.append('width', String(Math.max(1, width)));
      form.append('height', String(Math.max(1, height)));

      const res = await fetch('/api/crop-gif', { method: 'POST', body: form });
      if (!res.ok) {
        let message = `Failed to crop GIF (${res.status})`;
        try {
          const j = (await res.json()) as { error?: string };
          if (j?.error) message = j.error;
        } catch {
          // ignore
        }
        alert(message);
        return;
      }

      const blob = await res.blob();
      const file = new File([blob], 'cropped-image.gif', { type: 'image/gif' });
      applyCroppedFile(file, Math.max(1, width), Math.max(1, height));
      return;
    }

    // Convert canvas to blob (non-GIF)
    const outCanvas =
      cropShape === 'circle'
        ? circleCanvasFromSource(canvas)
        : roundedCanvasFromSource(canvas, cropBorderRadius);
    outCanvas.toBlob((blob) => {
      if (blob) {
        console.log('Blob created, size:', blob.size);
        const croppedFile = new File([blob], 'cropped-image.png', {
          type: 'image/png',
        });
        applyCroppedFile(croppedFile, coordinates.width, coordinates.height);
      } else {
        console.log('Failed to create blob');
      }
    }, 'image/png');
  }, [cropperRef, overlayImageUrl, overlayImage, cropBorderRadius, cropShape]);

  const insetCropSelection = useCallback(() => {
    const cropper = cropperRef.current;
    if (!cropper) return;

    try {
      const coords = cropper.getCoordinates();
      if (!coords) return;

      const minDim = Math.min(coords.width, coords.height);
      if (!(minDim > 0)) return;

      const inset = Math.max(2, Math.min(100, Math.round(minDim * 0.05)));
      const nextWidth = Math.max(1, Math.round(coords.width - inset * 2));
      const nextHeight = Math.max(1, Math.round(coords.height - inset * 2));
      if (nextWidth <= 1 || nextHeight <= 1) return;

      cropper.setCoordinates({
        width: nextWidth,
        height: nextHeight,
        left: Math.round(coords.left + inset),
        top: Math.round(coords.top + inset),
      });
    } catch {
      // ignore
    }
  }, []);

  const handleVideoLoad = useCallback(() => {
    const video = videoRef.current;
    if (video && video.duration) {
      setEndTime(video.duration);

      // Update container rect when video loads
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    }
  }, [getVideoContentRect]);

  // Ensure video element updates when videoUrl changes
  useEffect(() => {
    const video = videoRef.current;
    if (video && originalVideoUrl && video.src !== originalVideoUrl) {
      video.src = originalVideoUrl;
      video.load();
    }
  }, [originalVideoUrl]);

  const handleMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!overlayImageUrl) return;

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if clicking on the overlay image
      const overlayX = overlayPosition.x - overlaySize.width / 2;
      const overlayY = overlayPosition.y - overlaySize.height / 2;

      // Convert to pixels
      const overlayX_px = (overlayX / 100) * contentRect.width;
      const overlayY_px = (overlayY / 100) * contentRect.height;
      const overlayWidth_px = (overlaySize.width / 100) * contentRect.width;
      const overlayHeight_px = (overlaySize.height / 100) * contentRect.height;

      // Check if clicking near edges/corners for resizing (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= overlayX_px - edgeThreshold && x <= overlayX_px + edgeThreshold;
      const nearRightEdge =
        x >= overlayX_px + overlayWidth_px - edgeThreshold &&
        x <= overlayX_px + overlayWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= overlayY_px - edgeThreshold && y <= overlayY_px + edgeThreshold;
      const nearBottomEdge =
        y >= overlayY_px + overlayHeight_px - edgeThreshold &&
        y <= overlayY_px + overlayHeight_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      if (isNearEdge) {
        // Start resizing - determine resize direction based on which edges are near
        const startX = event.clientX;
        const startY = event.clientY;
        const startSize = { ...overlaySize };
        const startPos = { ...overlayPosition };
        const pointerId = event.pointerId;

        setIsResizing(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          // Allow free resizing without maintaining aspect ratio
          // Handle horizontal resizing
          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2; // Move position to keep right edge in place
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width + deltaX);
          }

          // Handle vertical resizing
          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2; // Move position to keep bottom edge in place
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height + deltaY);
          }

          setOverlaySize({
            width: Math.min(newWidth, 100),
            height: Math.min(newHeight, 100),
          });

          // Update position if resizing from top/left
          if (nearLeftEdge || nearTopEdge) {
            setOverlayPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          setIsResizing(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      } else if (
        x >= overlayX_px &&
        x <= overlayX_px + overlayWidth_px &&
        y >= overlayY_px &&
        y <= overlayY_px + overlayHeight_px
      ) {
        // Start dragging (center area)
        const startX = event.clientX;
        const startY = event.clientY;
        const startPos = { ...overlayPosition };
        const pointerId = event.pointerId;

        setIsDragging(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;

          setOverlayPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          setIsDragging(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [overlayImageUrl, overlayPosition, overlaySize, getVideoContentRect]
  );

  const handleTextMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!selectedWordText) return;

      const contentRect = containerRect
        ? {
            width: containerRect.width,
            height: containerRect.height,
            left: 0,
            top: 0,
          }
        : getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if clicking on the text overlay (calculate based on text content using percentages)
      const textWidthPercent = Math.min(
        95,
        (selectedWordText.length <= 3
          ? 35
          : selectedWordText.length <= 7
          ? 55
          : selectedWordText.length <= 12
          ? 70
          : 85) *
          (textOverlaySize.width / 20)
      );
      const textHeightPercent = Math.max(
        10,
        Math.min(85, (textOverlaySize.width / 100) * 60)
      );
      const textX = textOverlayPosition.x - textWidthPercent / 2;
      const textY = textOverlayPosition.y - textHeightPercent / 2;

      // Convert to pixels
      const textX_px = (textX / 100) * contentRect.width;
      const textY_px = (textY / 100) * contentRect.height;
      const textWidth_px = (textWidthPercent / 100) * contentRect.width;
      const textHeight_px = (textHeightPercent / 100) * contentRect.height;

      // Check if clicking near edges/corners for resizing (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= textX_px - edgeThreshold && x <= textX_px + edgeThreshold;
      const nearRightEdge =
        x >= textX_px + textWidth_px - edgeThreshold &&
        x <= textX_px + textWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= textY_px - edgeThreshold && y <= textY_px + edgeThreshold;
      const nearBottomEdge =
        y >= textY_px + textHeight_px - edgeThreshold &&
        y <= textY_px + textHeight_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      if (isNearEdge) {
        // Start resizing - determine resize direction based on which edges are near
        const startX = event.clientX;
        const startY = event.clientY;
        const startSize = { ...textOverlaySize };
        const startPos = { ...textOverlayPosition };
        const pointerId = event.pointerId;

        setIsResizingText(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          // Handle horizontal resizing
          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2; // Move position to keep right edge in place
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width + deltaX);
          }

          // Handle vertical resizing
          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2; // Move position to keep bottom edge in place
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height + deltaY);
          }

          setTextOverlaySize({
            width: Math.min(newWidth, 100),
            height: Math.min(newHeight, 100),
          });

          // Update position if resizing from top/left
          if (nearLeftEdge || nearTopEdge) {
            setTextOverlayPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          setIsResizingText(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      } else if (
        x >= textX_px &&
        x <= textX_px + textWidth_px &&
        y >= textY_px &&
        y <= textY_px + textHeight_px
      ) {
        // Start dragging (center area)
        const startX = event.clientX;
        const startY = event.clientY;
        const startPos = { ...textOverlayPosition };
        const pointerId = event.pointerId;

        setIsDraggingText(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;

          setTextOverlayPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          setIsDraggingText(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [
      selectedWordText,
      textOverlayPosition,
      textOverlaySize,
      getVideoContentRect,
      containerRect,
    ]
  );

  const handlePointerMove = useCallback(
    (event: React.PointerEvent) => {
      if (!overlayImageUrl) return;

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if hovering near edges/corners for resizing
      const overlayX = overlayPosition.x - overlaySize.width / 2;
      const overlayY = overlayPosition.y - overlaySize.height / 2;

      // Convert to pixels
      const overlayX_px = (overlayX / 100) * contentRect.width;
      const overlayY_px = (overlayY / 100) * contentRect.height;
      const overlayWidth_px = (overlaySize.width / 100) * contentRect.width;
      const overlayHeight_px = (overlaySize.height / 100) * contentRect.height;

      // Check if hovering near edges/corners (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= overlayX_px - edgeThreshold && x <= overlayX_px + edgeThreshold;
      const nearRightEdge =
        x >= overlayX_px + overlayWidth_px - edgeThreshold &&
        x <= overlayX_px + overlayWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= overlayY_px - edgeThreshold && y <= overlayY_px + edgeThreshold;
      const nearBottomEdge =
        y >= overlayY_px + overlayHeight_px - edgeThreshold &&
        y <= overlayY_px + overlayHeight_px + edgeThreshold;

      // Set cursor based on position
      if (nearLeftEdge && nearTopEdge) {
        document.body.style.cursor = 'nw-resize';
      } else if (nearRightEdge && nearTopEdge) {
        document.body.style.cursor = 'ne-resize';
      } else if (nearLeftEdge && nearBottomEdge) {
        document.body.style.cursor = 'sw-resize';
      } else if (nearRightEdge && nearBottomEdge) {
        document.body.style.cursor = 'se-resize';
      } else if (nearLeftEdge || nearRightEdge) {
        document.body.style.cursor = 'ew-resize';
      } else if (nearTopEdge || nearBottomEdge) {
        document.body.style.cursor = 'ns-resize';
      } else if (
        x >= overlayX_px &&
        x <= overlayX_px + overlayWidth_px &&
        y >= overlayY_px &&
        y <= overlayY_px + overlayHeight_px
      ) {
        document.body.style.cursor = 'move';
      } else {
        document.body.style.cursor = 'default';
      }
    },
    [overlayImageUrl, overlayPosition, overlaySize, getVideoContentRect]
  );

  const handlePointerLeave = useCallback(() => {
    document.body.style.cursor = 'default';
  }, []);

  const handleTintMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!isEditingTintArea) return;

      event.stopPropagation();

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      const rectLeft_px = (tintRect.left / 100) * contentRect.width;
      const rectTop_px = (tintRect.top / 100) * contentRect.height;
      const rectW_px = (tintRect.width / 100) * contentRect.width;
      const rectH_px = (tintRect.height / 100) * contentRect.height;

      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= rectLeft_px - edgeThreshold && x <= rectLeft_px + edgeThreshold;
      const nearRightEdge =
        x >= rectLeft_px + rectW_px - edgeThreshold &&
        x <= rectLeft_px + rectW_px + edgeThreshold;
      const nearTopEdge =
        y >= rectTop_px - edgeThreshold && y <= rectTop_px + edgeThreshold;
      const nearBottomEdge =
        y >= rectTop_px + rectH_px - edgeThreshold &&
        y <= rectTop_px + rectH_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      const startX = event.clientX;
      const startY = event.clientY;
      const startSize = { ...tintSize };
      const startPos = { ...tintPosition };
      const pointerId = event.pointerId;

      const minSizePct = 5;

      if (isNearEdge) {
        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(minSizePct, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2;
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(minSizePct, startSize.width + deltaX);
          }

          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(minSizePct, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2;
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(minSizePct, startSize.height + deltaY);
          }

          setTintSize({
            width: Math.min(100, Math.max(minSizePct, newWidth)),
            height: Math.min(100, Math.max(minSizePct, newHeight)),
          });

          if (nearLeftEdge || nearTopEdge) {
            setTintPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
        return;
      }

      // Drag when clicking inside the rect
      if (
        x >= rectLeft_px &&
        x <= rectLeft_px + rectW_px &&
        y >= rectTop_px &&
        y <= rectTop_px + rectH_px
      ) {
        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;
          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;
          setTintPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [
      getVideoContentRect,
      isEditingTintArea,
      tintPosition,
      tintRect.bottom,
      tintRect.height,
      tintRect.left,
      tintRect.right,
      tintRect.top,
      tintRect.width,
      tintSize,
    ]
  );

  const handleTintPointerMove = useCallback(
    (event: React.PointerEvent) => {
      if (!isEditingTintArea) return;
      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      const rectLeft_px = (tintRect.left / 100) * contentRect.width;
      const rectTop_px = (tintRect.top / 100) * contentRect.height;
      const rectW_px = (tintRect.width / 100) * contentRect.width;
      const rectH_px = (tintRect.height / 100) * contentRect.height;

      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= rectLeft_px - edgeThreshold && x <= rectLeft_px + edgeThreshold;
      const nearRightEdge =
        x >= rectLeft_px + rectW_px - edgeThreshold &&
        x <= rectLeft_px + rectW_px + edgeThreshold;
      const nearTopEdge =
        y >= rectTop_px - edgeThreshold && y <= rectTop_px + edgeThreshold;
      const nearBottomEdge =
        y >= rectTop_px + rectH_px - edgeThreshold &&
        y <= rectTop_px + rectH_px + edgeThreshold;

      if (nearLeftEdge && nearTopEdge) {
        document.body.style.cursor = 'nw-resize';
      } else if (nearRightEdge && nearTopEdge) {
        document.body.style.cursor = 'ne-resize';
      } else if (nearLeftEdge && nearBottomEdge) {
        document.body.style.cursor = 'sw-resize';
      } else if (nearRightEdge && nearBottomEdge) {
        document.body.style.cursor = 'se-resize';
      } else if (nearLeftEdge || nearRightEdge) {
        document.body.style.cursor = 'ew-resize';
      } else if (nearTopEdge || nearBottomEdge) {
        document.body.style.cursor = 'ns-resize';
      } else if (
        x >= rectLeft_px &&
        x <= rectLeft_px + rectW_px &&
        y >= rectTop_px &&
        y <= rectTop_px + rectH_px
      ) {
        document.body.style.cursor = 'move';
      } else {
        document.body.style.cursor = 'default';
      }
    },
    [getVideoContentRect, isEditingTintArea, tintRect]
  );

  const handlePreview = useCallback(async () => {
    if (
      !overlayImage &&
      !overlayImageUrl &&
      !selectedWordText &&
      !videoTintColor
    )
      return;
    if (!originalVideoUrl) return;
    console.log('handlePreview: textStyling', textStyling);

    setIsPreviewLoading(true);
    setPreviewUrl((prev) => {
      if (prev && prev.startsWith('blob:')) {
        try {
          URL.revokeObjectURL(prev);
        } catch {
          // ignore
        }
      }
      return null;
    });

    const formData = new FormData();
    formData.append('videoUrl', originalVideoUrl);
    formData.append('sceneId', sceneId.toString());

    const overlayFile = overlayImage
      ? overlayImage
      : overlayImageUrl
      ? await fetchOverlayFileFromUrl(overlayImageUrl)
      : null;

    if (overlayFile) {
      formData.append('overlayImage', overlayFile);
      if (overlayFile.type === 'image/gif') {
        formData.append('gifLoop', loopGif ? 'true' : 'false');
      }
    }
    if (selectedWordText) {
      formData.append('overlayText', selectedWordText);
    }
    formData.append(
      'positionX',
      (overlayFile ? overlayPosition.x : textOverlayPosition.x).toString()
    );
    formData.append(
      'positionY',
      (overlayFile ? overlayPosition.y : textOverlayPosition.y).toString()
    );
    formData.append(
      'sizeWidth',
      (overlayFile ? overlaySize.width : textOverlaySize.width).toString()
    );
    formData.append(
      'sizeHeight',
      (overlayFile ? overlaySize.height : textOverlaySize.height).toString()
    );
    formData.append('startTime', startTime.toString());
    formData.append('endTime', endTime.toString());
    formData.append('preview', 'true');
    if (videoTintColor) {
      formData.append('videoTintColor', videoTintColor);
      formData.append('videoTintOpacity', clamp01(videoTintOpacity).toString());
      formData.append('videoTintPositionX', tintPosition.x.toString());
      formData.append('videoTintPositionY', tintPosition.y.toString());
      formData.append('videoTintWidth', tintSize.width.toString());
      formData.append('videoTintHeight', tintSize.height.toString());
      formData.append('videoTintInvert', tintInvert ? 'true' : 'false');
    }
    if (selectedSoundName) {
      formData.append('overlaySound', selectedSoundName);
    }
    formData.append('overlayAnimation', overlayAnimation);
    if (selectedWordText && textStyling) {
      formData.append('textStyling', JSON.stringify(textStyling));
    }

    try {
      const response = await fetch('/api/add-image-overlay', {
        method: 'POST',
        body: formData,
      });

      const contentType = response.headers.get('content-type') || '';
      if (contentType.includes('video/')) {
        if (!response.ok) {
          setIsPreviewLoading(false);
          alert('Preview failed');
          return;
        }
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        setPreviewUrl(url);
        return;
      }

      const data = await response.json();
      if (data.success) {
        setPreviewUrl(data.url);
      } else {
        setIsPreviewLoading(false);
        alert('Preview failed: ' + data.error);
      }
    } catch {
      setIsPreviewLoading(false);
      alert('Error generating preview');
    }
  }, [
    overlayImage,
    overlayImageUrl,
    fetchOverlayFileFromUrl,
    loopGif,
    selectedWordText,
    videoTintColor,
    videoTintOpacity,
    originalVideoUrl,
    sceneId,
    overlayPosition,
    textOverlayPosition,
    overlaySize,
    textOverlaySize,
    startTime,
    endTime,
    textStyling,
    clamp01,
    tintInvert,
    tintPosition.x,
    tintPosition.y,
    tintSize.height,
    tintSize.width,
    selectedSoundName,
    overlayAnimation,
  ]);

  const handleApply = useCallback(async () => {
    if (
      !overlayImage &&
      !overlayImageUrl &&
      !selectedWordText &&
      !videoTintColor
    )
      return;

    const undoKey = sceneId ? `scene-undo-video-url:${sceneId}` : null;
    const urlBeforeApply = originalVideoUrl;

    try {
      console.log(
        'handleApply: sending textStyling',
        selectedWordText ? textStyling : undefined
      );

      const overlayFile = overlayImage
        ? overlayImage
        : overlayImageUrl
        ? await fetchOverlayFileFromUrl(overlayImageUrl)
        : null;

      // Apply overlay to the CURRENT video playing in the modal
      await onApply(
        sceneId,
        overlayFile,
        selectedWordText,
        overlayFile ? overlayPosition : textOverlayPosition,
        overlayFile ? overlaySize : textOverlaySize,
        startTime,
        endTime,
        selectedWordText ? textStyling : undefined,
        videoTintColor,
        videoTintOpacity,
        tintPosition,
        tintSize,
        tintInvert,
        selectedSoundName,
        overlayAnimation,
        loopGif
      );

      // After applying, fetch the scene from the DB to get the updated video URL
      // Retry a few times in case the DB update hasn't fully propagated
      const maxRetries = 6;
      let attempts = 0;
      let sceneData: { field_6886?: unknown } | null = null;
      let newUrl: string | undefined;
      while (attempts < maxRetries) {
        sceneData = (await getSceneById(sceneId)) as {
          field_6886?: unknown;
        } | null;
        newUrl =
          typeof sceneData?.field_6886 === 'string'
            ? sceneData.field_6886
            : undefined;
        if (newUrl && newUrl !== urlBeforeApply) break;
        await new Promise((res) => setTimeout(res, 500));
        attempts++;
      }

      if (newUrl) {
        // Save previous URL for undo (best-effort, client-side persistence).
        if (urlBeforeApply && urlBeforeApply !== newUrl) {
          setPreviousVideoUrl(urlBeforeApply);
          if (undoKey && typeof window !== 'undefined') {
            try {
              localStorage.setItem(undoKey, urlBeforeApply);
            } catch {
              // ignore
            }
          }
        }

        setOriginalVideoUrl(newUrl);
        // Notify parent so subsequent applies use the new video URL
        if (onUpdateModalVideoUrl) {
          onUpdateModalVideoUrl(newUrl);
        }
      }

      // Force a refetch of transcription and other modal data
      // but avoid triggering this refetch during batch operations to prevent
      // per-loop data refreshes that lead to UI flicker.
      if (!useAppStore.getState().batchOperations.transcribingAllFinalScenes) {
        setRefetchTrigger((prev) => prev + 1);
      }

      // Reset overlay state to defaults (like opening a fresh modal) but keep it open
      setOverlayImage(null);
      setOverlayImageUrl(null);
      setOverlayPosition({ x: 50, y: 50 });
      setOverlaySize({ width: 40, height: 40 });
      setPreviewUrl(null);
      setIsPreviewLoading(false);
      setSelectedWordText(null);
      setCustomText('');
      setStartTime(0);
      setEndTime(0);
      setVideoTintColor(null);
      setVideoTintOpacity(1);
      setTintPosition({ x: 50, y: 50 });
      setTintSize({ width: 100, height: 100 });
      setTintInvert(false);
      setIsEditingTintArea(false);
      setSelectedSoundName(null);
      setOverlayAnimation('miniZoom');
      setIsTintSectionOpen(false);
      setIsTextStylingSectionOpen(false);
      setIsSoundSectionOpen(false);
      setIsAnimationSectionOpen(false);
      setLoopGif(false);
      setIsCropping(false);
      setActualImageDimensions(null);
      setTextOverlayPosition({ x: 50, y: 50 });
      setTextOverlaySize({ width: 100, height: 100 });
      setTextStyling(() => {
        const saved = localStorage.getItem('defaultTextStyling');
        return saved
          ? JSON.parse(saved)
          : {
              fontColor: '#ffffff',
              borderWidth: 3,
              borderColor: '#000000',
              shadowX: 8,
              shadowY: 8,
              shadowColor: '#000000',
              shadowOpacity: 0.9,
              fontFamily: 'Helvetica',
              bgColor: '#000000',
              bgOpacity: 0.65,
              bgSize: 8,
            };
      });
    } catch (error) {
      console.error('Failed to apply overlay and refresh modal:', error);
    }
  }, [
    overlayImage,
    overlayImageUrl,
    fetchOverlayFileFromUrl,
    loopGif,
    selectedWordText,
    textStyling,
    videoTintColor,
    videoTintOpacity,
    tintInvert,
    tintPosition,
    tintSize,
    selectedSoundName,
    sceneId,
    overlayPosition,
    overlaySize,
    textOverlayPosition,
    textOverlaySize,
    startTime,
    endTime,
    overlayAnimation,
    onApply,
    onUpdateModalVideoUrl,
    originalVideoUrl,
  ]);

  const handleGenerateScenePrompt = useCallback(async () => {
    if (!sceneId) return;
    if (!selectedOpenRouterModel) {
      setScenePromptStatus('No AI model selected');
      return;
    }

    setIsGeneratingScenePrompt(true);
    setScenePromptStatus(null);

    try {
      const genRes = await fetch('/api/generate-scene-prompt', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sceneId,
          model: selectedOpenRouterModel,
        }),
      });

      if (!genRes.ok) {
        const t = await genRes.text().catch(() => '');
        throw new Error(`Prompt generation failed: ${genRes.status} ${t}`);
      }

      const genData = (await genRes.json().catch(() => null)) as {
        scenePrompt?: unknown;
        promptFieldKey?: unknown;
      } | null;
      const scenePrompt =
        typeof genData?.scenePrompt === 'string' ? genData.scenePrompt : null;
      const promptFieldKey =
        typeof genData?.promptFieldKey === 'string'
          ? genData.promptFieldKey
          : null;

      if (!scenePrompt || !scenePrompt.trim()) {
        throw new Error('Prompt generation returned empty prompt');
      }

      if (!promptFieldKey) {
        throw new Error(
          'Prompt generation did not return a valid promptFieldKey'
        );
      }

      const patchRes = await fetch(`/api/baserow/scenes/${sceneId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          [promptFieldKey]: scenePrompt,
        }),
      });

      if (!patchRes.ok) {
        const t = await patchRes.text().catch(() => '');
        throw new Error(`Failed to save scene prompt: ${patchRes.status} ${t}`);
      }

      setScenePromptStatus('Saved');
      window.setTimeout(() => setScenePromptStatus(null), 2500);
    } catch (error) {
      console.error('Failed to generate/save scene prompt:', error);
      setScenePromptStatus(
        error instanceof Error ? error.message : 'Failed to generate prompt'
      );
    } finally {
      setIsGeneratingScenePrompt(false);
    }
  }, [sceneId, selectedOpenRouterModel]);

  const handleGenerateSceneImage = useCallback(async () => {
    if (!sceneId) return;

    setIsGeneratingSceneImage(true);
    setSceneImageStatus(null);

    try {
      const genRes = await fetch('/api/generate-scene-image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ sceneId }),
      });

      if (!genRes.ok) {
        const t = await genRes.text().catch(() => '');
        throw new Error(`Image generation failed: ${genRes.status} ${t}`);
      }

      const genData = (await genRes.json().catch(() => null)) as {
        imageUrl?: unknown;
      } | null;

      const imageUrl =
        typeof genData?.imageUrl === 'string' ? genData.imageUrl : null;

      if (!imageUrl || !imageUrl.trim()) {
        throw new Error('Image generation returned empty imageUrl');
      }

      // Load generated image into the overlay slot as well.
      await loadOverlayFromRemoteUrl(imageUrl);
      if (fileInputRef.current) fileInputRef.current.value = '';

      setSceneImageStatus('Saved');
      window.setTimeout(() => setSceneImageStatus(null), 2500);
    } catch (error) {
      console.error('Failed to generate/save scene image:', error);
      setSceneImageStatus(
        error instanceof Error ? error.message : 'Failed to generate image'
      );
    } finally {
      setIsGeneratingSceneImage(false);
    }
  }, [sceneId, loadOverlayFromRemoteUrl]);

  const handleUpscaleSceneImage = useCallback(async () => {
    if (!sceneId) return;

    setIsUpscalingSceneImage(true);
    setSceneUpscaleStatus(null);

    try {
      const res = await fetch('/api/upscale-scene-image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ sceneId }),
      });

      if (!res.ok) {
        const t = await res.text().catch(() => '');
        throw new Error(`Upscale failed: ${res.status} ${t}`);
      }

      const data = (await res.json().catch(() => null)) as {
        imageUrl?: unknown;
      } | null;

      const imageUrl =
        typeof data?.imageUrl === 'string' ? data.imageUrl : null;
      if (!imageUrl || !imageUrl.trim()) {
        throw new Error('Upscale returned empty imageUrl');
      }

      // Load upscaled image into the overlay slot as well.
      await loadOverlayFromRemoteUrl(imageUrl);
      if (fileInputRef.current) fileInputRef.current.value = '';

      setSceneUpscaleStatus('Saved');
      window.setTimeout(() => setSceneUpscaleStatus(null), 2500);
    } catch (error) {
      console.error('Failed to upscale/save scene image:', error);
      setSceneUpscaleStatus(
        error instanceof Error ? error.message : 'Failed to upscale image'
      );
    } finally {
      setIsUpscalingSceneImage(false);
    }
  }, [sceneId, loadOverlayFromRemoteUrl]);

  const handleReturnToPreviousUrl = useCallback(async () => {
    if (!sceneId) return;
    if (!previousVideoUrl) return;
    if (isApplying) return;

    const undoKey = `scene-undo-video-url:${sceneId}`;

    try {
      const res = await fetch(`/api/baserow/scenes/${sceneId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ field_6886: previousVideoUrl }),
      });

      if (!res.ok) {
        const t = await res.text().catch(() => '');
        alert(`Failed to return video URL (${res.status}) ${t}`);
        return;
      }

      const updated = (await res.json().catch(() => null)) as {
        field_6886?: unknown;
      } | null;
      const updatedUrl =
        updated && typeof updated.field_6886 === 'string'
          ? updated.field_6886
          : null;
      if (updatedUrl && updatedUrl !== previousVideoUrl) {
        alert(
          'Undo request succeeded, but Baserow returned a different URL than expected.'
        );
      }

      setOriginalVideoUrl(previousVideoUrl);
      onUpdateModalVideoUrl?.(previousVideoUrl);

      // Clear undo state after returning.
      setPreviousVideoUrl(null);
      if (typeof window !== 'undefined') {
        try {
          localStorage.removeItem(undoKey);
        } catch {
          // ignore
        }
      }

      // Refresh transcription/modal data for the restored scene.
      setRefetchTrigger((prev) => prev + 1);
    } catch (err) {
      console.error('Failed to return to previous video URL:', err);
      alert('Failed to return to previous video URL');
    }
  }, [sceneId, previousVideoUrl, isApplying, onUpdateModalVideoUrl]);

  const handleClose = useCallback(() => {
    onClose();
    // Reset state
    setOverlayImage(null);
    setOverlayImageUrl(null);
    setOverlayPosition({ x: 50, y: 50 });
    setOverlaySize({ width: 40, height: 40 });
    setStartTime(0);
    setEndTime(0);
    setVideoTintColor(null);
    setVideoTintOpacity(1);
    setTintPosition({ x: 50, y: 50 });
    setTintSize({ width: 100, height: 100 });
    setTintInvert(false);
    setIsEditingTintArea(false);
    setSelectedSoundName(null);
    setOverlayAnimation('miniZoom');
    setIsTintSectionOpen(false);
    setIsTextStylingSectionOpen(false);
    setIsSoundSectionOpen(false);
    setIsAnimationSectionOpen(false);
    setPreviewUrl(null);
    setIsPreviewLoading(false);
    setIsGeneratingScenePrompt(false);
    setScenePromptStatus(null);
    setSceneImageStatus(null);
    setTranscriptionWords(null);
    setSelectedWordText(null);
    setCustomText('');
    setSelectedWordText(null);
  }, [onClose]);

  // Fetch transcription data
  useEffect(() => {
    if (isOpen && sceneId) {
      setIsTintSectionOpen(false);
      setIsTextStylingSectionOpen(false);
      // Clear any leftover preview state when modal opens
      setPreviewUrl(null);
      setIsPreviewLoading(false);
      // Set the original video URL when we have a valid video URL
      if (videoUrl && videoUrl.trim() !== '') {
        setOriginalVideoUrl(videoUrl);

        // Load previous URL for undo if present.
        if (typeof window !== 'undefined') {
          try {
            const undoKey = `scene-undo-video-url:${sceneId}`;
            const saved = localStorage.getItem(undoKey);
            setPreviousVideoUrl(saved && saved.trim() ? saved : null);
          } catch {
            setPreviousVideoUrl(null);
          }
        }

        // Best-effort: warm the server-side cache so previews don't repeatedly
        // download/stream from MinIO across requests.
        void fetch('/api/warm-video-cache', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoUrl }),
        }).catch(() => {
          // ignore
        });
      }

      const fetchTranscription = async () => {
        try {
          // Fetch scene data from Baserow to get the Captions URL
          const sceneData = await getSceneById(sceneId);

          // Try different possible field names and specific field IDs
          let captionsUrl = null;

          // First try the specific field that contains captions URL
          if (
            sceneData?.['field_6910'] &&
            typeof sceneData['field_6910'] === 'string' &&
            (sceneData['field_6910'].startsWith('http') ||
              sceneData['field_6910'].includes('.json'))
          ) {
            captionsUrl = sceneData['field_6910'];
          }

          // Then try other possible field names
          if (!captionsUrl) {
            captionsUrl =
              sceneData?.['Captions URL'] ||
              sceneData?.['captions_url'] ||
              sceneData?.['CaptionsURL'] ||
              sceneData?.['captions URL'];
          }

          // Finally try other field IDs that might contain captions (only if they look like URLs)
          if (!captionsUrl) {
            const possibleFields = [
              'field_6892',
              'field_6893',
              'field_6894',
              'field_6895',
              'field_6897',
              'field_6898',
              'field_6899',
            ];
            for (const field of possibleFields) {
              const value = sceneData?.[field];
              if (
                value &&
                typeof value === 'string' &&
                (value.startsWith('http') || value.includes('.json'))
              ) {
                captionsUrl = value;
                break;
              }
            }
          }

          if (captionsUrl) {
            const response = await fetch(captionsUrl as string);
            if (response.ok) {
              const data = await response.json();
              setTranscriptionWords(data);
            } else {
              setTranscriptionWords(null);
            }
          } else {
            setTranscriptionWords(null);
          }
        } catch (error) {
          console.error('Failed to fetch transcription:', error);
          setTranscriptionWords(null);
        }
      };
      fetchTranscription();
    } else {
      // Modal is closed, clear transcription data
      setTranscriptionWords(null);
    }
  }, [isOpen, sceneId, refetchTrigger, videoUrl]);

  // Handle keyboard controls
  useEffect(() => {
    if (!isOpen) return;

    let tabKeyDown = false;
    let tabHoldTriggered = false;
    let tabHoldTimer: ReturnType<typeof setTimeout> | null = null;

    const stopAll = (event: KeyboardEvent) => {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
    };

    const clearTabHoldTimer = () => {
      if (tabHoldTimer) {
        clearTimeout(tabHoldTimer);
        tabHoldTimer = null;
      }
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      // If VideoEditModal is open, don't handle keyboard events in this modal
      if (isVideoEditModalOpen) {
        return;
      }

      if (event.code === 'Tab') {
        // When the preview overlay is open, Tab should close it.
        if (previewUrl) {
          stopAll(event);
          setPreviewUrl(null);
          setIsPreviewLoading(false);
          return;
        }

        // Otherwise, in the main modal, Tab triggers Preview.
        if (!isCropping) {
          stopAll(event);
          const isPreviewDisabled =
            !(
              overlayImage ||
              overlayImageUrl ||
              selectedWordText ||
              videoTintColor
            ) ||
            isApplying ||
            isPreviewLoading;

          if (!isPreviewDisabled) {
            void handlePreview();
          } else {
            // Preview is disabled: Tab controls the main player.
            // - Tap Tab: toggle play/pause (handled on keyup)
            // - Hold Tab: restart from the beginning and play
            if (!tabKeyDown) {
              tabKeyDown = true;
              tabHoldTriggered = false;
              clearTabHoldTimer();
              tabHoldTimer = setTimeout(() => {
                tabHoldTriggered = true;
                const video = videoRef.current;
                if (video) {
                  try {
                    video.currentTime = 0;
                  } catch {
                    // Ignore seek errors
                  }
                  video.play().catch(() => {
                    // Ignore autoplay/gesture errors; user explicitly pressed a key.
                  });
                }
              }, 300);
            }
          }
          return;
        }
      }

      if (event.code === 'Escape') {
        stopAll(event);
        // If the crop popup is open, Esc should only close that.
        if (isCropping) {
          setIsCropping(false);
          return;
        }

        // 1) Exit preview if open
        if (previewUrl) {
          setPreviewUrl(null);
          setIsPreviewLoading(false);
          return;
        }

        // 2) Clear overlays on canvas first (image/text)
        if (overlayImageUrl || selectedWordText) {
          if (overlayImageUrl) {
            handleRemoveImage();
          }
          if (selectedWordText) {
            setSelectedWordText(null);
            setCustomText('');
          }
          return;
        }

        // 3) Nothing to clear -> close modal
        handleClose();
        return;
      }

      // Alt+1: paste overlay image from clipboard
      if (
        event.key === '1' &&
        event.altKey &&
        !event.metaKey &&
        !event.ctrlKey
      ) {
        // If an input or editable element is focused, allow typing.
        const target = event.target as Element | null;
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return;
        }

        stopAll(event);

        const ua =
          typeof navigator !== 'undefined' && navigator.userAgent
            ? navigator.userAgent
            : '';
        const isSafari =
          /Safari\//.test(ua) &&
          !/Chrome\//.test(ua) &&
          !/Chromium\//.test(ua) &&
          !/Edg\//.test(ua) &&
          !/OPR\//.test(ua);

        // Best-effort: trigger a real paste event (Cmd/Ctrl+V equivalent)
        // without using the async Clipboard API (Safari tends to show a system
        // paste UI and may block clipboard reads).
        setIsPastingOverlayFromClipboard(true);
        forceHandleOverlayPasteRef.current = true;

        const sink = pasteSinkRef.current;
        if (sink) {
          sink.focus();
          sink.select();
        }

        let ok = false;
        try {
          ok =
            typeof document.execCommand === 'function' &&
            document.execCommand('paste');
        } catch {
          ok = false;
        }

        if (!ok) {
          // Firefox/Chrome block execCommand('paste'); fall back to async clipboard
          // reads (these browsers usually present a permission prompt once).
          forceHandleOverlayPasteRef.current = false;
          if (isSafari) {
            setIsPastingOverlayFromClipboard(false);
          } else {
            void handlePasteOverlayImageFromClipboard();
          }
        }
        return;
      }

      if (
        event.key === '1' &&
        !event.ctrlKey &&
        !event.metaKey &&
        !event.altKey
      ) {
        // If an input or editable element is focused, allow typing.
        const target = event.target as Element | null;
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return;
        }

        stopAll(event);
        const video = previewUrl ? previewVideoRef.current : videoRef.current;
        if (video) {
          video.currentTime = 0;
          video.play().catch(() => {
            // Ignore autoplay/gesture errors; user explicitly pressed a key.
          });
        }
        return;
      }

      if (event.code === 'Space') {
        // If an input or editable element is focused, allow the spacebar to
        // insert text rather than control player playback.
        const target = event.target as Element | null;
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return; // allow normal typing behavior
        }

        stopAll(event);
        const video = previewUrl ? previewVideoRef.current : videoRef.current;
        if (video) {
          if (video.paused) {
            video.play();
          } else {
            video.pause();
          }
        }
      }
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      if (event.code !== 'Tab') return;
      if (!tabKeyDown) return;

      stopAll(event);

      tabKeyDown = false;
      clearTabHoldTimer();

      // If the hold action already fired, do nothing on keyup.
      if (tabHoldTriggered) {
        tabHoldTriggered = false;
        return;
      }

      tabHoldTriggered = false;

      // Tap-to-toggle only applies when Preview is disabled.
      if (previewUrl) return;
      if (isCropping) return;

      const isPreviewDisabled =
        !(overlayImage || selectedWordText || videoTintColor) ||
        isApplying ||
        isPreviewLoading;

      if (!isPreviewDisabled) return;

      const video = videoRef.current;
      if (video) {
        if (video.paused) {
          video.play().catch(() => {
            // Ignore autoplay/gesture errors; user explicitly pressed a key.
          });
        } else {
          video.pause();
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown, { capture: true });
    document.addEventListener('keyup', handleKeyUp, { capture: true });
    return () => {
      clearTabHoldTimer();
      tabKeyDown = false;
      tabHoldTriggered = false;
      document.removeEventListener('keydown', handleKeyDown, {
        capture: true,
      });
      document.removeEventListener('keyup', handleKeyUp, {
        capture: true,
      });
    };
  }, [
    isOpen,
    previewUrl,
    handleClose,
    overlayImageUrl,
    selectedWordText,
    handleRemoveImage,
    isCropping,
    overlayImage,
    videoTintColor,
    isApplying,
    isPreviewLoading,
    handlePreview,
    handlePasteOverlayImageFromClipboard,
    isVideoEditModalOpen,
  ]);

  // Update container dimensions
  useEffect(() => {
    const updateContainerRect = () => {
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    };

    // Update immediately
    updateContainerRect();

    // Update on window resize
    window.addEventListener('resize', updateContainerRect);
    return () => window.removeEventListener('resize', updateContainerRect);
  }, [getVideoContentRect]);

  // Prevent scrolling the page behind the modal.
  useEffect(() => {
    if (!isOpen) return;

    const html = document.documentElement;
    const body = document.body;

    const prevHtmlOverflow = html.style.overflow;
    const prevBodyOverflow = body.style.overflow;
    const prevBodyPaddingRight = body.style.paddingRight;

    const scrollbarWidth = Math.max(0, window.innerWidth - html.clientWidth);

    html.style.overflow = 'hidden';
    body.style.overflow = 'hidden';
    if (scrollbarWidth > 0) {
      body.style.paddingRight = `${scrollbarWidth}px`;
    }

    return () => {
      html.style.overflow = prevHtmlOverflow;
      body.style.overflow = prevBodyOverflow;
      body.style.paddingRight = prevBodyPaddingRight;
    };
  }, [isOpen]);

  // Update container dimensions
  useEffect(() => {
    const updateContainerRect = () => {
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    };

    // Update immediately
    updateContainerRect();

    // Update on window resize
    window.addEventListener('resize', updateContainerRect);
    return () => window.removeEventListener('resize', updateContainerRect);
  }, [getVideoContentRect]);

  if (!isOpen) return null;

  return (
    <div className='fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'>
      <div className='bg-white rounded-lg p-8 w-full mx-2 h-[95vh] overflow-hidden flex flex-col'>
        <div className='flex justify-between items-center mb-4'>
          <h2 className='text-xl font-semibold'>Add Image Overlay</h2>
          <div className='flex items-center gap-4'>
            <div className='flex items-center gap-2'>
              <button
                type='button'
                onClick={handleGenerateScenePrompt}
                disabled={isApplying || isGeneratingScenePrompt}
                className='px-3 py-1 text-sm font-medium bg-gray-100 hover:bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed'
                title='Generate and save storyboard prompt for this scene'
              >
                {isGeneratingScenePrompt ? (
                  <span className='inline-flex items-center gap-2'>
                    <Loader2 className='h-4 w-4 animate-spin' />
                    Prompt
                  </span>
                ) : (
                  'Prompt'
                )}
              </button>
              <button
                type='button'
                onClick={handleGenerateSceneImage}
                disabled={
                  isApplying || isGeneratingSceneImage || isUpscalingSceneImage
                }
                className='px-3 py-1 text-sm font-medium bg-gray-100 hover:bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed'
                title='Generate image with Nano Banana Pro and save to Baserow (Image for Scene)'
              >
                {isGeneratingSceneImage ? (
                  <span className='inline-flex items-center gap-2'>
                    <Loader2 className='h-4 w-4 animate-spin' />
                    Image
                  </span>
                ) : (
                  'Image'
                )}
              </button>
              <button
                type='button'
                onClick={handleUpscaleSceneImage}
                disabled={
                  isApplying || isUpscalingSceneImage || isGeneratingSceneImage
                }
                className='px-3 py-1 text-sm font-medium bg-gray-100 hover:bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed'
                title='Upscale current scene image (Image for Scene) and save to Baserow (Upscaled Image for Scene)'
              >
                {isUpscalingSceneImage ? (
                  <span className='inline-flex items-center gap-2'>
                    <Loader2 className='h-4 w-4 animate-spin' />
                    Upscale
                  </span>
                ) : (
                  'Upscale'
                )}
              </button>
              {scenePromptStatus ? (
                <span className='text-xs text-gray-600 max-w-[280px] truncate'>
                  {scenePromptStatus}
                </span>
              ) : null}
              {sceneImageStatus ? (
                <span className='text-xs text-gray-600 max-w-[280px] truncate'>
                  {sceneImageStatus}
                </span>
              ) : null}
              {sceneUpscaleStatus ? (
                <span className='text-xs text-gray-600 max-w-[280px] truncate'>
                  {sceneUpscaleStatus}
                </span>
              ) : null}
            </div>
            <div className='text-sm font-mono bg-gray-100 px-3 py-1 rounded'>
              {Math.floor(timerSeconds / 60)}:
              {(timerSeconds % 60).toString().padStart(2, '0')}
            </div>
            <button
              onClick={handleClose}
              className='p-1 hover:bg-gray-100 rounded'
            >
              <X className='h-5 w-5' />
            </button>
          </div>
        </div>

        <div className='grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1 min-h-0 items-start'>
          {/* Video Preview */}
          <div
            className='relative lg:col-span-2 w-full aspect-video self-start'
            onPointerDown={isEditingTintArea ? undefined : handleMouseDown}
            onPointerMove={isEditingTintArea ? undefined : handlePointerMove}
            onPointerLeave={handlePointerLeave}
          >
            {originalVideoUrl ? (
              <video
                key={originalVideoUrl}
                ref={videoRef}
                src={originalVideoUrl}
                className='w-full h-full object-contain object-top rounded border'
                controls
                crossOrigin='anonymous'
                onLoadedMetadata={handleVideoLoad}
              />
            ) : (
              <div className='w-full h-full flex items-center justify-center bg-gray-100 rounded border'>
                <div className='text-gray-500 text-center'>
                  <div className='text-lg mb-2'>📹</div>
                  <div>Loading video...</div>
                </div>
              </div>
            )}
            {shouldShowTintOverlay && videoTintColor && (
              <>
                {!tintInvert ? (
                  <div
                    className='absolute pointer-events-none'
                    style={{
                      left: `${tintRect.left}%`,
                      top: `${tintRect.top}%`,
                      width: `${tintRect.width}%`,
                      height: `${tintRect.height}%`,
                      backgroundColor: videoTintColor,
                      opacity: clamp01(videoTintOpacity),
                    }}
                  />
                ) : (
                  <>
                    {tintRect.top > 0 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: 0,
                          top: 0,
                          right: 0,
                          height: `${tintRect.top}%`,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                    {tintRect.bottom < 100 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: 0,
                          top: `${tintRect.bottom}%`,
                          right: 0,
                          bottom: 0,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                    {tintRect.left > 0 && tintRect.height > 0 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: 0,
                          top: `${tintRect.top}%`,
                          width: `${tintRect.left}%`,
                          height: `${tintRect.height}%`,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                    {tintRect.right < 100 && tintRect.height > 0 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: `${tintRect.right}%`,
                          top: `${tintRect.top}%`,
                          right: 0,
                          height: `${tintRect.height}%`,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                  </>
                )}
              </>
            )}

            {isEditingTintArea && (
              <div
                className='absolute pointer-events-auto z-30'
                style={{
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: '40px',
                }}
                onPointerDown={handleTintMouseDown}
                onPointerMove={handleTintPointerMove}
                onPointerLeave={handlePointerLeave}
              >
                <div
                  className='absolute border-2 border-blue-500'
                  style={{
                    left: `${tintRect.left}%`,
                    top: `${tintRect.top}%`,
                    width: `${tintRect.width}%`,
                    height: `${tintRect.height}%`,
                  }}
                />
              </div>
            )}
            {/* Invisible overlay to capture clicks when there's an overlay - excludes controls area */}
            {overlayImageUrl && (
              <div
                className='absolute pointer-events-auto z-5'
                style={{
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: '40px', // Leave space for video controls at bottom
                }}
                onPointerDown={(e) => {
                  // Only prevent default if clicking in overlay area
                  const contentRect = getVideoContentRect();
                  if (!contentRect) return;

                  const x = e.clientX - contentRect.left;
                  const y = e.clientY - contentRect.top;

                  const overlayX = overlayPosition.x - overlaySize.width / 2;
                  const overlayY = overlayPosition.y - overlaySize.height / 2;
                  const overlayX_px = (overlayX / 100) * contentRect.width;
                  const overlayY_px = (overlayY / 100) * contentRect.height;
                  const overlayWidth_px =
                    (overlaySize.width / 100) * contentRect.width;
                  const overlayHeight_px =
                    (overlaySize.height / 100) * contentRect.height;

                  // If clicking within overlay bounds, handle overlay interaction
                  if (
                    x >= overlayX_px &&
                    x <= overlayX_px + overlayWidth_px &&
                    y >= overlayY_px &&
                    y <= overlayY_px + overlayHeight_px
                  ) {
                    handleMouseDown(e);
                  } else {
                    // Outside overlay - allow video surface clicks (but not controls)
                    // This will still prevent accidental play/pause on video surface
                    e.preventDefault();
                  }
                }}
              />
            )}
            {overlayImageUrl && (
              <div
                className='absolute border-2 border-blue-500 cursor-move pointer-events-auto z-20'
                style={{
                  left: `${overlayPosition.x}%`,
                  top: `${overlayPosition.y}%`,
                  width: `${overlaySize.width}%`,
                  height: `${overlaySize.height}%`,
                  transform: 'translate(-50%, -50%)',
                }}
                onPointerDown={handleMouseDown}
                onWheel={handleOverlayWheelZoom}
                onContextMenu={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  cycleOverlaySound();
                }}
                onDoubleClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  openCropModal();
                }}
              >
                <img
                  src={overlayImageUrl}
                  alt='Overlay'
                  className='w-full h-full object-contain'
                  draggable={false}
                  onPointerDown={handleMouseDown}
                />
              </div>
            )}
            {selectedWordText && (
              <div
                className='absolute border border-green-500 cursor-move pointer-events-auto z-10 rounded'
                style={{
                  left: `${textOverlayPosition.x}%`,
                  top: `${textOverlayPosition.y}%`,
                  transform: 'translate(-50%, -50%)',
                  width: `${Math.max(
                    10,
                    Math.min(
                      95,
                      (selectedWordText.length <= 3
                        ? 35
                        : selectedWordText.length <= 7
                        ? 55
                        : selectedWordText.length <= 12
                        ? 70
                        : 85) *
                        (textOverlaySize.width / 20)
                    )
                  )}%`,
                  height: `${Math.max(
                    8,
                    Math.min(85, (textOverlaySize.width / 100) * 60)
                  )}%`,
                  // Match server-side font sizing (in video pixels), then scale to CSS pixels.
                  fontSize: `${(() => {
                    const v = videoRef.current;
                    if (!v?.videoWidth || !v?.videoHeight) {
                      return Math.max(8, (textOverlaySize.width / 100) * 120);
                    }
                    const fontSizeVideoPx = Math.max(
                      16,
                      Math.min(
                        500,
                        (textOverlaySize.width / 100) *
                          Math.min(v.videoWidth, v.videoHeight) *
                          0.2
                      )
                    );
                    return Math.max(1, fontSizeVideoPx * videoToCssScale);
                  })()}px`,
                }}
                onPointerDown={handleTextMouseDown}
                onWheel={handleTextOverlayWheelZoom}
                onContextMenu={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  cycleOverlaySound();
                }}
                onDoubleClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  cycleNextTextPreset();
                }}
              >
                <div
                  className='w-full h-full flex items-center justify-center font-bold select-none whitespace-normal break-words text-center'
                  style={{
                    color: textStyling.fontColor,
                    textShadow: `${textStyling.shadowX * videoToCssScale}px ${
                      textStyling.shadowY * videoToCssScale
                    }px 0px rgba(${hexToRgb(textStyling.shadowColor)}, ${
                      textStyling.shadowOpacity
                    })`,
                    WebkitTextStroke:
                      textStyling.borderWidth > 0
                        ? `${textStyling.borderWidth * videoToCssScale}px ${
                            textStyling.borderColor
                          }`
                        : 'none',
                    fontWeight: 'bold',
                    fontFamily: textStyling.fontFamily,
                    backgroundColor: textStyling.bgColor
                      ? `rgba(${hexToRgb(textStyling.bgColor)}, ${
                          textStyling.bgOpacity ?? 1
                        })`
                      : undefined,
                    padding: textStyling.bgSize
                      ? `${textStyling.bgSize * videoToCssScale}px`
                      : undefined,
                    borderRadius: textStyling.bgSize ? '4px' : undefined,
                  }}
                >
                  {selectedWordText}
                </div>
              </div>
            )}
          </div>

          {/* Controls */}
          <div className='space-y-4 overflow-y-auto min-h-0 self-stretch h-full pr-1'>
            {/* Hidden paste sink for Ctrl+1 programmatic paste */}
            <textarea
              ref={pasteSinkRef}
              tabIndex={-1}
              aria-hidden='true'
              className='sr-only'
              value=''
              readOnly
            />
            {/* Image Upload */}
            <ImageUploadRow
              fileInputRef={fileInputRef}
              overlayImage={overlayImage}
              isGifOverlay={isGifOverlay}
              loopGif={loopGif}
              onChangeLoopGif={setLoopGif}
              onImageUpload={handleImageUpload}
              onPickFile={() => fileInputRef.current?.click()}
              onScreenshot={handleScreenshot}
              onCopyToClipboard={handleCopyOverlayImageToClipboard}
              onPasteFromClipboard={handlePasteOverlayImageFromClipboard}
              isPastingFromClipboard={isPastingOverlayFromClipboard}
              onRemoveImage={handleRemoveImage}
              videoFileInputRef={videoFileInputRef}
              onVideoUpload={handleVideoUpload}
              onPickVideoFile={() => videoFileInputRef.current?.click()}
            />

            {/* Position Controls */}
            {/* Position and Size Controls */}
            {overlayImageUrl && (
              <ImagePositionControls
                overlayPosition={overlayPosition}
                setOverlayPosition={setOverlayPosition}
                overlaySize={overlaySize}
                setOverlaySize={setOverlaySize}
                actualImageDimensions={actualImageDimensions}
                onCrop={openCropModal}
                onCenterResetNatural={() => {
                  setOverlayPosition({ x: 50, y: 50 });
                  void (async () => {
                    const dims =
                      actualImageDimensions ??
                      (await ensureOverlayImageDimensions());
                    if (dims) {
                      setOverlaySizeFromPixels(dims.width, dims.height);
                      return;
                    }
                    setOverlaySize({ width: 25, height: 25 });
                  })();
                }}
                onCenterMaximize={() => {
                  setOverlayPosition({ x: 50, y: 50 });
                  setOverlaySize({ width: 100, height: 100 });
                }}
                onZoomOut={() => {
                  setOverlaySize((prev) => ({
                    width: Math.max(5, prev.width * 0.9),
                    height: Math.max(5, prev.height * 0.9),
                  }));
                }}
                onZoomIn={() => {
                  setOverlaySize((prev) => ({
                    width: Math.min(100, prev.width * 1.1),
                    height: Math.min(100, prev.height * 1.1),
                  }));
                }}
              />
            )}

            {/* Timing Controls */}
            <TimingTintControls
              startTime={startTime}
              endTime={endTime}
              setStartTime={(v) => setStartTime(v)}
              setEndTime={(v) => setEndTime(v)}
              onSetStartFromCurrent={() => {
                const video = videoRef.current;
                if (video) setStartTime(video.currentTime);
              }}
              onSetEndFromCurrent={() => {
                const video = videoRef.current;
                if (video) setEndTime(video.currentTime);
              }}
              isTintSectionOpen={isTintSectionOpen}
              setIsTintSectionOpen={setIsTintSectionOpen}
              tintPalette={tintPalette}
              videoTintColor={videoTintColor}
              setVideoTintColor={setVideoTintColor}
              videoTintOpacity={videoTintOpacity}
              setVideoTintOpacity={setVideoTintOpacity}
              clamp01={clamp01}
              isEditingTintArea={isEditingTintArea}
              setIsEditingTintArea={setIsEditingTintArea}
              tintInvert={tintInvert}
              setTintInvert={setTintInvert}
            />

            <div className='mt-2 grid grid-cols-2 gap-2'>
              <div className='bg-gray-50 p-2 rounded-lg border border-gray-200'>
                <div
                  role='button'
                  tabIndex={0}
                  onClick={() => setIsSoundSectionOpen((s) => !s)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      setIsSoundSectionOpen((s) => !s);
                    }
                  }}
                  className='w-full flex items-center justify-between gap-2 text-sm text-gray-700 cursor-pointer select-none'
                  aria-expanded={isSoundSectionOpen}
                >
                  <div className='flex items-center gap-2 min-w-0'>
                    <span>Sound</span>
                    {!isSoundSectionOpen && (
                      <span className='text-xs text-gray-500 truncate'>
                        {selectedSoundName ?? 'None'}
                      </span>
                    )}
                  </div>

                  <div className='flex items-center gap-2'>
                    <button
                      type='button'
                      onClick={(e) => {
                        e.stopPropagation();
                        setSelectedSoundName(null);
                      }}
                      className={`px-2 py-1 text-xs rounded border bg-white ${
                        !selectedSoundName
                          ? 'border-gray-700 text-gray-900'
                          : 'border-gray-300 text-gray-700'
                      }`}
                    >
                      None
                    </button>
                    {isSoundSectionOpen ? (
                      <ChevronDown className='h-4 w-4' />
                    ) : (
                      <ChevronRight className='h-4 w-4' />
                    )}
                  </div>
                </div>

                {isSoundSectionOpen && (
                  <div className='mt-2 flex flex-wrap gap-2'>
                    {availableSounds.map((s) => (
                      <button
                        key={s.name}
                        type='button'
                        onClick={() => setSelectedSoundName(s.name)}
                        className={`px-2 py-1 text-xs rounded border bg-white ${
                          selectedSoundName === s.name
                            ? 'border-gray-700 text-gray-900'
                            : 'border-gray-300 text-gray-700'
                        }`}
                        title={s.name}
                      >
                        {s.name}
                      </button>
                    ))}

                    {availableSounds.length === 0 && (
                      <span className='text-xs text-gray-500'>
                        No sounds found in /public/sounds
                      </span>
                    )}
                  </div>
                )}
              </div>

              <div className='bg-gray-50 p-2 rounded-lg border border-gray-200'>
                <div
                  role='button'
                  tabIndex={0}
                  onClick={() => setIsAnimationSectionOpen((s) => !s)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      setIsAnimationSectionOpen((s) => !s);
                    }
                  }}
                  className='w-full flex items-center justify-between gap-2 text-sm text-gray-700 cursor-pointer select-none'
                  aria-expanded={isAnimationSectionOpen}
                >
                  <div className='flex items-center gap-2 min-w-0'>
                    <span>Animation</span>
                    {!isAnimationSectionOpen && (
                      <span className='text-xs text-gray-500 truncate'>
                        {animationLabel}
                      </span>
                    )}
                  </div>

                  <div className='flex items-center gap-2'>
                    <button
                      type='button'
                      onClick={(e) => {
                        e.stopPropagation();
                        setOverlayAnimation('none');
                      }}
                      className={`px-2 py-1 text-xs rounded border bg-white ${
                        overlayAnimation === 'none'
                          ? 'border-gray-700 text-gray-900'
                          : 'border-gray-300 text-gray-700'
                      }`}
                    >
                      None
                    </button>
                    {isAnimationSectionOpen ? (
                      <ChevronDown className='h-4 w-4' />
                    ) : (
                      <ChevronRight className='h-4 w-4' />
                    )}
                  </div>
                </div>

                {isAnimationSectionOpen && (
                  <div className='mt-2 grid grid-cols-3 gap-2'>
                    {(
                      [
                        { id: 'bounceIn', label: 'Bounce In' },
                        { id: 'spring', label: 'Spring' },
                        { id: 'fadeIn', label: 'Fade In' },
                        { id: 'miniZoom', label: 'Mini Zoom' },
                        { id: 'zoomIn', label: 'Zoom In' },
                        { id: 'slideLeft', label: 'Slide Left' },
                        { id: 'slideRight', label: 'Slide Right' },
                        { id: 'slideUp', label: 'Slide Up' },
                      ] as const
                    ).map((opt) => (
                      <button
                        key={opt.id}
                        type='button'
                        onClick={() => setOverlayAnimation(opt.id)}
                        className={`px-2 py-2 text-xs rounded border bg-white text-left ${
                          overlayAnimation === opt.id
                            ? 'border-gray-700 text-gray-900'
                            : 'border-gray-300 text-gray-700'
                        }`}
                      >
                        {opt.label}
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>

            <TranscriptionControls
              transcriptionWords={transcriptionWords}
              customText={customText}
              selectedWordText={selectedWordText}
              onWordClick={(wordData) => {
                setStartTime(wordData.start);
                const raw = (wordData.word || '').trim();
                const cleaned = raw.replace(/[，,]+$/g, '').trim();
                setCustomText(cleaned.toUpperCase());
                if (videoRef.current) {
                  videoRef.current.currentTime = wordData.start;
                }
              }}
              onWordRightClick={(wordData) => {
                const t = Number.isFinite(wordData.end)
                  ? Math.max(0, wordData.end)
                  : 0;
                setEndTime(t);
              }}
              onWordDoubleClick={(wordData) => {
                setStartTime(wordData.start);
                const raw = (wordData.word || '').trim();
                const cleaned = raw.replace(/[，,]+$/g, '').trim();
                const text = cleaned.toUpperCase();

                // Match + button behavior: set input and add to canvas (text overlay), and clear image overlay.
                setCustomText(text);
                setSelectedWordText(text);
                setOverlayImage(null);
                setOverlayImageUrl(null);
                if (fileInputRef.current) fileInputRef.current.value = '';

                if (videoRef.current) {
                  videoRef.current.currentTime = wordData.start;
                }
              }}
              onCustomTextChange={setCustomText}
              onCustomTextEnter={() => {
                if (customText.trim()) {
                  setSelectedWordText(customText.trim());
                  setOverlayImage(null);
                  setOverlayImageUrl(null);
                  if (fileInputRef.current) fileInputRef.current.value = '';
                }
              }}
              onAddText={() => {
                if (customText.trim()) {
                  setSelectedWordText(customText.trim());
                  setOverlayImage(null);
                  setOverlayImageUrl(null);
                  if (fileInputRef.current) fileInputRef.current.value = '';
                }
              }}
              onClearText={() => {
                setSelectedWordText(null);
                setCustomText('');
                setPreviewUrl(null);
                setIsPreviewLoading(false);
              }}
              onInsertFull={() => {
                if (transcriptionWords && transcriptionWords.length > 0) {
                  const allText = transcriptionWords
                    .map((w) => w.word)
                    .join(' ');
                  setCustomText((allText || '').toUpperCase());
                }
              }}
              canTranscribe={!!handleTranscribeScene}
              onTranscribe={async () => {
                if (!handleTranscribeScene) return;
                setIsTranscribing(true);
                try {
                  await handleTranscribeScene(sceneId, undefined, 'final');
                  if (
                    !useAppStore.getState().batchOperations
                      .transcribingAllFinalScenes
                  ) {
                    setRefetchTrigger((prev) => prev + 1);
                  }
                } catch (error) {
                  console.error('Failed to transcribe:', error);
                } finally {
                  setIsTranscribing(false);
                }
              }}
              onRetranscribe={async () => {
                if (!handleTranscribeScene) return;
                setIsTranscribing(true);
                try {
                  await handleTranscribeScene(sceneId, undefined, 'final');
                  if (
                    !useAppStore.getState().batchOperations
                      .transcribingAllFinalScenes
                  ) {
                    setRefetchTrigger((prev) => prev + 1);
                  }
                } catch (error) {
                  console.error('Failed to retranscribe:', error);
                } finally {
                  setIsTranscribing(false);
                }
              }}
              isTranscribing={isTranscribing}
              isInsertFullDisabled={
                !transcriptionWords ||
                transcriptionWords.length === 0 ||
                customText.trim() ===
                  (transcriptionWords || [])
                    .map((w) => w.word)
                    .join(' ')
                    .trim()
              }
            />

            {selectedWordText && (
              <TextOverlayControls
                textOverlayPosition={textOverlayPosition}
                setTextOverlayPosition={setTextOverlayPosition}
                textOverlaySize={textOverlaySize}
                setTextOverlaySize={setTextOverlaySize}
                isTextStylingSectionOpen={isTextStylingSectionOpen}
                setIsTextStylingSectionOpen={setIsTextStylingSectionOpen}
                textStyling={textStyling}
                setTextStyling={setTextStyling}
                ffmpegFonts={ffmpegFonts as Record<string, string>}
                availableFontFamilies={availableFontFamilies}
                showFontPreview={showFontPreview}
                setShowFontPreview={setShowFontPreview}
                isFontLoaded={isFontLoaded}
                saveCurrentTextStyle={saveCurrentTextStyle}
                savedTextStyles={savedTextStyles}
                applySavedTextStyle={applySavedTextStyle}
                deleteSavedTextStyle={deleteSavedTextStyle}
              />
            )}
          </div>
        </div>

        {/* Action Buttons */}
        <div className='flex justify-end space-x-3 mt-6 pt-4 border-t'>
          <button
            onClick={handleClose}
            className='px-4 py-2 text-gray-600 hover:bg-gray-100 rounded'
            disabled={isApplying}
          >
            Cancel
          </button>
          <button
            onClick={handlePreview}
            ref={previewButtonRef}
            disabled={
              !(
                overlayImage ||
                overlayImageUrl ||
                selectedWordText ||
                videoTintColor
              ) ||
              isApplying ||
              isPreviewLoading
            }
            className='flex items-center space-x-2 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed'
          >
            {isPreviewLoading ? (
              <Loader2 className='animate-spin h-4 w-4' />
            ) : null}
            <span>{isPreviewLoading ? 'Loading...' : 'Preview'}</span>
          </button>
          <button
            onClick={handleReturnToPreviousUrl}
            disabled={!previousVideoUrl || isApplying}
            className='flex items-center space-x-2 px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed'
            title={
              previousVideoUrl
                ? 'Return to previous video URL'
                : 'No previous URL saved yet'
            }
          >
            <span>Return</span>
          </button>
          <button
            onClick={handleApply}
            disabled={
              !(
                overlayImage ||
                overlayImageUrl ||
                selectedWordText ||
                videoTintColor
              ) || isApplying
            }
            className='flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed'
          >
            {isApplying ? (
              <Loader2 className='animate-spin h-4 w-4' />
            ) : (
              <span>Apply Overlay</span>
            )}
          </button>
        </div>
      </div>

      {/* Cropping Modal */}
      {isCropping && overlayImageUrl && (
        <div className='fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'>
          <div className='bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] w-full mx-4'>
            <div className='flex justify-between items-center mb-4'>
              <h3 className='text-lg font-semibold'>Crop Image</h3>
              <button
                onClick={() => {
                  setIsCropping(false);
                }}
                className='p-1 hover:bg-gray-100 rounded'
              >
                <X className='h-5 w-5' />
              </button>
            </div>

            <div className='flex flex-col items-center space-y-4'>
              <div className='flex space-x-4 w-full'>
                <div className='flex-1'>
                  <h4 className='text-sm font-medium mb-2'>Select Crop Area</h4>
                  <div
                    className='border rounded overflow-hidden bg-gray-100 flex items-center justify-center'
                    onDoubleClick={async (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      if (cropperRef.current && overlayImage) {
                        await applyCrop();
                      }
                    }}
                    title='Double-click to apply crop'
                  >
                    <div
                      className='relative'
                      style={
                        cropperViewportPx
                          ? {
                              width: `${cropperViewportPx.width}px`,
                              height: `${cropperViewportPx.height}px`,
                            }
                          : {
                              width: '100%',
                              height: '384px',
                            }
                      }
                    >
                      <Cropper
                        key={`${overlayImageUrl}-${cropperModalKey}`}
                        src={overlayImageUrl}
                        ref={cropperRef}
                        className={'w-full h-full'}
                        style={{
                          height: '100%',
                          width: '100%',
                          backgroundColor: '#f3f4f6',
                          ['--crop-stencil-radius' as never]: `${cropBorderRadius}%`,
                        }}
                        stencilProps={{
                          aspectRatio: undefined,
                          // Locked stencil: dragging pans the image.
                          // Unlocked stencil: dragging moves/resizes the stencil.
                          movable:
                            !isCropStencilLocked && cropEditorMode === 'crop',
                          resizable:
                            !isCropStencilLocked && cropEditorMode === 'crop',
                          lines:
                            !isCropStencilLocked && cropEditorMode === 'crop',
                          handlers:
                            !isCropStencilLocked && cropEditorMode === 'crop',
                          previewClassName:
                            cropShape === 'rectangle'
                              ? 'overflow-hidden rounded-[var(--crop-stencil-radius)]'
                              : undefined,
                          boundingBoxClassName:
                            cropShape === 'rectangle'
                              ? 'rounded-[var(--crop-stencil-radius)]'
                              : undefined,
                          overlayClassName:
                            cropEditorMode === 'crop'
                              ? undefined
                              : 'opacity-50',
                        }}
                        backgroundWrapperProps={{
                          scaleImage: cropEditorMode === 'crop',
                          moveImage:
                            cropEditorMode === 'crop' && isCropStencilLocked,
                        }}
                        imageRestriction={ImageRestriction.stencil}
                        stencilComponent={
                          cropShape === 'circle' ? CircleStencil : undefined
                        }
                        {...(!isGifOverlay
                          ? {
                              backgroundComponent: AdjustableCropperBackground,
                              backgroundProps: cropAdjustments,
                            }
                          : {})}
                        checkOrientation={false}
                        onReady={() => {
                          const cropper = cropperRef.current;
                          if (!cropper) return;

                          // Ensure the initial stencil starts flush to the image
                          // (no inset). Run once per open.
                          const initKey = `${overlayImageUrl}-${cropperModalKey}`;
                          if (didInitCropCoordinatesRef.current === initKey) {
                            return;
                          }
                          didInitCropCoordinatesRef.current = initKey;

                          // Defer one tick so the cropper has computed image geometry.
                          setTimeout(() => {
                            const c = cropperRef.current;
                            if (!c) return;
                            try {
                              const img = c.getImage() as unknown as {
                                width?: number;
                                height?: number;
                                left?: number;
                                top?: number;
                              };
                              const w =
                                typeof img?.width === 'number'
                                  ? img.width
                                  : null;
                              const h =
                                typeof img?.height === 'number'
                                  ? img.height
                                  : null;
                              if (!(w && h && w > 0 && h > 0)) return;

                              c.setCoordinates({
                                width: w,
                                height: h,
                                left:
                                  typeof img.left === 'number' ? img.left : 0,
                                top: typeof img.top === 'number' ? img.top : 0,
                              });
                            } catch {
                              // ignore
                            }
                          }, 0);
                        }}
                      />
                    </div>
                  </div>
                </div>
              </div>

              <div className='flex flex-wrap items-center justify-center gap-2 w-full'>
                <button
                  type='button'
                  onClick={() => setCropEditorMode('crop')}
                  className={`px-3 py-2 border rounded hover:bg-gray-50 ${
                    cropEditorMode === 'crop'
                      ? 'bg-gray-100'
                      : 'border-gray-300'
                  }`}
                >
                  Crop
                </button>
                {(
                  [
                    ['brightness', 'Brightness'],
                    ['contrast', 'Contrast'],
                    ['saturation', 'Saturation'],
                    ['hue', 'Hue'],
                  ] as const
                ).map(([key, label]) => (
                  <button
                    key={key}
                    type='button'
                    onClick={() => setCropEditorMode(key)}
                    disabled={isGifOverlay}
                    className={`px-3 py-2 border rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed ${
                      cropEditorMode === key ? 'bg-gray-100' : 'border-gray-300'
                    }`}
                  >
                    {label}
                  </button>
                ))}
              </div>

              {cropEditorMode !== 'crop' && !isGifOverlay && (
                <div className='flex items-center gap-3 w-full'>
                  <label className='text-sm text-gray-700 w-24'>
                    {cropEditorMode.charAt(0).toUpperCase() +
                      cropEditorMode.slice(1)}
                  </label>
                  <input
                    type='range'
                    min={-1}
                    max={1}
                    step={0.01}
                    value={cropAdjustments[cropEditorMode]}
                    onChange={(e) => {
                      const v = Number(e.target.value);
                      setCropAdjustments((prev) => ({
                        ...prev,
                        [cropEditorMode]: v,
                      }));
                    }}
                    className='flex-1'
                  />
                  <span className='text-sm text-gray-700 w-16 text-right'>
                    {Math.round(cropAdjustments[cropEditorMode] * 100)}%
                  </span>
                </div>
              )}

              {cropEditorMode === 'crop' && (
                <div className='flex flex-wrap items-center justify-center gap-3 w-full'>
                  <button
                    type='button'
                    onClick={() => setIsCropStencilLocked((v) => !v)}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50'
                    title={
                      isCropStencilLocked
                        ? 'Unlock the crop stencil so you can move/resize it'
                        : 'Lock the crop stencil so dragging pans the image'
                    }
                  >
                    {isCropStencilLocked ? 'Unlock Stencil' : 'Lock Stencil'}
                  </button>
                  <button
                    type='button'
                    onClick={() => setCropShape('rectangle')}
                    className={`px-3 py-2 border rounded hover:bg-gray-50 ${
                      cropShape === 'rectangle'
                        ? 'bg-gray-100'
                        : 'border-gray-300'
                    }`}
                  >
                    Rectangle
                  </button>
                  <button
                    type='button'
                    onClick={() => setCropShape('circle')}
                    disabled={isGifOverlay}
                    className={`px-3 py-2 border rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed ${
                      cropShape === 'circle' ? 'bg-gray-100' : 'border-gray-300'
                    }`}
                  >
                    Circle
                  </button>

                  <button
                    type='button'
                    onClick={insetCropSelection}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50'
                    title='Inset (shrink) the crop area'
                  >
                    Inset
                  </button>

                  <button
                    type='button'
                    onClick={() => {
                      const current =
                        cropperRef.current?.getTransforms()?.rotate ??
                        cropRotationDegrees;
                      setCropRotationAbsolute(current - 90);
                    }}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Rotate Left
                  </button>
                  <button
                    type='button'
                    onClick={() => {
                      const current =
                        cropperRef.current?.getTransforms()?.rotate ??
                        cropRotationDegrees;
                      setCropRotationAbsolute(current + 90);
                    }}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Rotate Right
                  </button>

                  <div className='flex items-center gap-2 min-w-[260px]'>
                    <label className='text-sm text-gray-700'>Rotate (°)</label>
                    <input
                      type='range'
                      min={-180}
                      max={180}
                      step={1}
                      value={cropRotationDegrees}
                      onChange={(e) =>
                        setCropRotationAbsolute(Number(e.target.value))
                      }
                      disabled={isGifOverlay}
                      className='flex-1 disabled:opacity-50 disabled:cursor-not-allowed'
                    />
                    <input
                      type='number'
                      min={-180}
                      max={180}
                      step={1}
                      value={cropRotationDegrees}
                      onChange={(e) =>
                        setCropRotationAbsolute(Number(e.target.value))
                      }
                      disabled={isGifOverlay}
                      className='w-20 px-2 py-1 border border-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed'
                    />
                  </div>
                  <button
                    type='button'
                    onClick={() => cropperRef.current?.flipImage(true, false)}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Flip Horizontal
                  </button>
                  <button
                    type='button'
                    onClick={() => cropperRef.current?.flipImage(false, true)}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Flip Vertical
                  </button>

                  <div className='flex items-center gap-2 min-w-[280px]'>
                    <label className='text-sm text-gray-700'>
                      Border radius
                    </label>
                    <input
                      type='range'
                      min={0}
                      max={100}
                      value={cropBorderRadius}
                      onChange={(e) =>
                        setCropBorderRadius(Number(e.target.value))
                      }
                      disabled={isGifOverlay || cropShape === 'circle'}
                      className='flex-1 disabled:opacity-50 disabled:cursor-not-allowed'
                    />
                    <span className='text-sm text-gray-700 w-12 text-right'>
                      {cropBorderRadius}%
                    </span>
                  </div>
                </div>
              )}

              <div className='flex space-x-2'>
                <button
                  onClick={() => {
                    setIsCropping(false);
                  }}
                  className='px-4 py-2 border border-gray-300 rounded hover:bg-gray-50'
                >
                  Cancel
                </button>
                <button
                  onClick={async () => {
                    console.log(
                      'Apply crop clicked, cropperRef.current:',
                      cropperRef.current
                    );
                    console.log('overlayImage:', overlayImage);
                    if (cropperRef.current && overlayImage) {
                      console.log('Calling applyCrop');
                      await applyCrop();
                    } else {
                      console.log('Conditions not met for applyCrop');
                    }
                  }}
                  className='px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600'
                  disabled={!overlayImage}
                >
                  Apply Crop
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Preview Video Overlay */}
      {previewUrl && (
        <div
          className='fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'
          onClick={() => {
            setPreviewUrl((prev) => {
              if (prev && prev.startsWith('blob:')) {
                try {
                  URL.revokeObjectURL(prev);
                } catch {
                  // ignore
                }
              }
              return null;
            });
            setIsPreviewLoading(false);
          }}
        >
          <div className='relative max-w-4xl max-h-[80vh] w-full mx-4'>
            <button
              onClick={(e) => {
                e.stopPropagation();
                setPreviewUrl((prev) => {
                  if (prev && prev.startsWith('blob:')) {
                    try {
                      URL.revokeObjectURL(prev);
                    } catch {
                      // ignore
                    }
                  }
                  return null;
                });
                setIsPreviewLoading(false);
              }}
              className='absolute -top-10 right-0 text-white hover:text-gray-300 text-xl font-bold'
            >
              ✕
            </button>
            <div className='w-full' onClick={(e) => e.stopPropagation()}>
              <div className='relative w-full rounded-lg overflow-hidden'>
                <video
                  src={previewUrl as string}
                  autoPlay
                  playsInline
                  disablePictureInPicture
                  crossOrigin='anonymous'
                  className='w-full h-full'
                  ref={previewVideoRef}
                  onCanPlay={() => setIsPreviewLoading(false)}
                  onLoadedData={() => setIsPreviewLoading(false)}
                  onError={() => setIsPreviewLoading(false)}
                />

                {/* Interaction layer: prevents native video double-click fullscreen and
                    turns double-click into Apply Overlay. */}
                <div
                  className='absolute inset-0'
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  }}
                  onDoubleClickCapture={(e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    if (!isApplying) {
                      void handleApply();
                    }

                    // Close preview immediately (and revoke blob URLs) to avoid the
                    // perception that nothing happened.
                    setPreviewUrl((prev) => {
                      if (prev && prev.startsWith('blob:')) {
                        try {
                          URL.revokeObjectURL(prev);
                        } catch {
                          // ignore
                        }
                      }
                      return null;
                    });
                    setIsPreviewLoading(false);
                  }}
                />
              </div>

              {/* Minimal player controls under the video */}
              <div className='mt-3 flex items-center gap-3 text-white select-none'>
                <button
                  type='button'
                  className='px-3 py-1 rounded bg-white/10 hover:bg-white/20'
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const v = previewVideoRef.current;
                    if (!v) return;
                    if (v.paused) {
                      v.play().catch(() => {
                        // ignore
                      });
                    } else {
                      v.pause();
                    }
                  }}
                >
                  {isPreviewPaused ? 'Play' : 'Pause'}
                </button>

                <input
                  type='range'
                  min={0}
                  max={Math.max(0, previewDurationSeconds)}
                  step={0.01}
                  value={Math.min(
                    previewCurrentTimeSeconds,
                    previewDurationSeconds || 0
                  )}
                  className='flex-1'
                  onChange={(e) => {
                    e.stopPropagation();
                    const v = previewVideoRef.current;
                    if (!v) return;
                    const next = Number(e.currentTarget.value);
                    if (Number.isFinite(next)) v.currentTime = next;
                  }}
                  onClick={(e) => e.stopPropagation()}
                />

                <div className='tabular-nums text-sm text-white/90 w-28 text-right'>
                  {previewCurrentTimeSeconds.toFixed(1)}s /{' '}
                  {previewDurationSeconds.toFixed(1)}s
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Video Edit Modal */}
      <VideoEditModal
        isOpen={isVideoEditModalOpen}
        onClose={() => setIsVideoEditModalOpen(false)}
        videoFile={overlayVideo}
        videoUrl={overlayVideoUrl}
        onSaveGif={(gifBlob) => {
          // Convert blob to file and set as overlay image
          const gifFile = new File([gifBlob], 'video-gif.gif', {
            type: 'image/gif',
          });
          setOverlayImage(gifFile);
          setOverlayImageUrl(URL.createObjectURL(gifFile));
          setOverlayVideo(null);
          setOverlayVideoUrl(null);
          setIsVideoEditModalOpen(false);
        }}
      />
    </div>
  );
};
