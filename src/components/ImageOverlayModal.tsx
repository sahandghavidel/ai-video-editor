'use client';

import React, {
  useState,
  useRef,
  useCallback,
  useEffect,
  useMemo,
} from 'react';
import { useAppStore } from '@/store/useAppStore';
import { X, Loader2, ChevronDown, ChevronRight } from 'lucide-react';
import { getSceneById } from '@/lib/baserow-actions';
// fonts mapping generated by scripts/generate_ffmpeg_fonts.py
// this file contains a mapping of family => sample font path present on the machine
import ffmpegFonts from '../../docs/ffmpeg-fonts.json';
import { Cropper, CropperRef, CircleStencil } from 'react-advanced-cropper';
import 'react-advanced-cropper/dist/style.css';
import { getBackgroundStyle } from 'advanced-cropper';

import { ImageUploadRow } from './image-overlay-modal/ImageUploadRow';
import { ImagePositionControls } from './image-overlay-modal/ImagePositionControls';
import { TimingTintControls } from './image-overlay-modal/TimingTintControls';
import { TranscriptionControls } from './image-overlay-modal/TranscriptionControls';
import { TextOverlayControls } from './image-overlay-modal/TextOverlayControls';
import type {
  TextStyling,
  TranscriptionWord,
} from './image-overlay-modal/types';

type CropEditorMode = 'crop' | 'brightness' | 'contrast' | 'saturation' | 'hue';

type CropAdjustments = {
  brightness: number;
  contrast: number;
  saturation: number;
  hue: number;
};

type CropShape = 'rectangle' | 'circle';

// Helper function to convert hex color to RGB
const hexToRgb = (hex: string) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(
        result[3],
        16
      )}`
    : '0, 0, 0';
};

function roundedCanvasFromSource(
  source: HTMLCanvasElement,
  radiusPercent: number
): HTMLCanvasElement {
  if (!(radiusPercent > 0)) return source;

  const w = source.width;
  const h = source.height;
  const ctxRadius = Math.round(
    (Math.min(w, h) / 2) * Math.min(1, Math.max(0, radiusPercent / 100))
  );
  if (!(ctxRadius > 0)) return source;

  const out = document.createElement('canvas');
  out.width = w;
  out.height = h;
  const ctx = out.getContext('2d');
  if (!ctx) return source;

  const r = Math.min(ctxRadius, Math.floor(Math.min(w, h) / 2));

  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(r, 0);
  ctx.lineTo(w - r, 0);
  ctx.quadraticCurveTo(w, 0, w, r);
  ctx.lineTo(w, h - r);
  ctx.quadraticCurveTo(w, h, w - r, h);
  ctx.lineTo(r, h);
  ctx.quadraticCurveTo(0, h, 0, h - r);
  ctx.lineTo(0, r);
  ctx.quadraticCurveTo(0, 0, r, 0);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(source, 0, 0);
  ctx.restore();

  return out;
}

function circleCanvasFromSource(source: HTMLCanvasElement): HTMLCanvasElement {
  const w = source.width;
  const h = source.height;
  if (!(w > 0 && h > 0)) return source;

  const out = document.createElement('canvas');
  out.width = w;
  out.height = h;
  const ctx = out.getContext('2d');
  if (!ctx) return source;

  const r = Math.min(w, h) / 2;
  const cx = w / 2;
  const cy = h / 2;

  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(source, 0, 0);
  ctx.restore();

  return out;
}

function mergeRefs<T>(refs: Array<React.Ref<T> | undefined>) {
  return (value: T | null) => {
    for (const ref of refs) {
      if (!ref) continue;
      if (typeof ref === 'function') {
        ref(value);
      } else {
        try {
          (ref as React.MutableRefObject<T | null>).current = value;
        } catch {
          // ignore
        }
      }
    }
  };
}

const AdjustableImage = React.forwardRef<
  HTMLCanvasElement,
  {
    src?: string;
    className?: string;
    crossOrigin?: 'anonymous' | 'use-credentials' | boolean;
    brightness?: number;
    saturation?: number;
    hue?: number;
    contrast?: number;
    style?: React.CSSProperties;
  }
>(
  (
    {
      src,
      className,
      crossOrigin,
      brightness = 0,
      saturation = 0,
      hue = 0,
      contrast = 0,
      style,
    },
    ref
  ) => {
    const imageRef = useRef<HTMLImageElement | null>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);

    const drawImage = useCallback(() => {
      const image = imageRef.current;
      const canvas = canvasRef.current;
      if (!canvas || !image || !image.complete) return;

      const w = image.naturalWidth;
      const h = image.naturalHeight;
      if (!(w > 0 && h > 0)) return;

      const ctx = canvas.getContext('2d');
      canvas.width = w;
      canvas.height = h;
      if (!ctx) return;

      ctx.clearRect(0, 0, w, h);
      ctx.filter = [
        `brightness(${100 + brightness * 100}%)`,
        `contrast(${100 + contrast * 100}%)`,
        `saturate(${100 + saturation * 100}%)`,
        `hue-rotate(${hue * 360}deg)`,
      ].join(' ');
      ctx.drawImage(image, 0, 0, w, h);
    }, [brightness, contrast, saturation, hue]);

    useEffect(() => {
      if (!src) {
        imageRef.current = null;
        return;
      }

      const img = new Image();
      if (crossOrigin) {
        img.crossOrigin = crossOrigin === true ? 'anonymous' : crossOrigin;
      }
      img.onload = () => {
        imageRef.current = img;
        drawImage();
      };
      img.src = src;
      imageRef.current = img;

      // Attempt a draw in case it was cached.
      drawImage();

      return () => {
        if (imageRef.current === img) {
          imageRef.current = null;
        }
      };
    }, [drawImage, src, crossOrigin]);

    return (
      <>
        <canvas
          key={`${src || 'no-src'}-canvas`}
          ref={mergeRefs([ref, canvasRef])}
          className={className}
          style={style}
        />
      </>
    );
  }
);
AdjustableImage.displayName = 'AdjustableImage';

const AdjustableCropperBackground = React.forwardRef<
  HTMLCanvasElement,
  {
    className?: string;
    cropper: CropperRef;
    crossOrigin?: 'anonymous' | 'use-credentials' | boolean;
    brightness?: number;
    saturation?: number;
    hue?: number;
    contrast?: number;
  }
>(
  (
    {
      className,
      cropper,
      crossOrigin,
      brightness = 0,
      saturation = 0,
      hue = 0,
      contrast = 0,
    },
    ref
  ) => {
    const state = cropper.getState();
    const transitions = cropper.getTransitions();
    const image = cropper.getImage();
    const style =
      image && state ? getBackgroundStyle(image, state, transitions) : {};

    return (
      <AdjustableImage
        src={image?.src}
        crossOrigin={crossOrigin}
        brightness={brightness}
        saturation={saturation}
        hue={hue}
        contrast={contrast}
        ref={ref}
        className={className}
        style={style}
      />
    );
  }
);
AdjustableCropperBackground.displayName = 'AdjustableCropperBackground';

type OverlayAnimation =
  | 'none'
  | 'bounceIn'
  | 'spring'
  | 'fadeIn'
  | 'miniZoom'
  | 'zoomIn'
  | 'slideLeft'
  | 'slideRight'
  | 'slideUp';

interface ImageOverlayModalProps {
  isOpen: boolean;
  onClose: () => void;
  videoUrl: string;
  sceneId: number;
  onApply: (
    sceneId: number,
    overlayImage: File | null,
    overlayText: string | null,
    position: { x: number; y: number },
    size: { width: number; height: number },
    startTime: number,
    endTime: number,
    textStyling?: TextStyling,
    videoTintColor?: string | null,
    videoTintOpacity?: number,
    tintPosition?: { x: number; y: number },
    tintSize?: { width: number; height: number },
    tintInvert?: boolean,
    overlaySound?: string | null,
    overlayAnimation?: OverlayAnimation
  ) => Promise<void>;
  isApplying?: boolean;
  handleTranscribeScene?: (
    sceneId: number,
    sceneData?: unknown,
    videoType?: 'original' | 'final',
    skipRefresh?: boolean,
    skipSound?: boolean
  ) => Promise<void>;
  onUpdateModalVideoUrl?: (videoUrl: string) => void;
}

export const ImageOverlayModal: React.FC<ImageOverlayModalProps> = ({
  isOpen,
  onClose,
  videoUrl,
  sceneId,
  onApply,
  isApplying = false,
  handleTranscribeScene,
  onUpdateModalVideoUrl,
}) => {
  const [availableSounds, setAvailableSounds] = useState<
    { name: string; url: string }[]
  >([]);
  const [selectedSoundName, setSelectedSoundName] = useState<string | null>(
    'pop.wav'
  );
  const [overlayAnimation, setOverlayAnimation] =
    useState<OverlayAnimation>('miniZoom');
  const [overlayImage, setOverlayImage] = useState<File | null>(null);
  const [overlayImageUrl, setOverlayImageUrl] = useState<string | null>(null);
  const [overlayPosition, setOverlayPosition] = useState({ x: 50, y: 50 }); // percentage
  const [overlaySize, setOverlaySize] = useState({ width: 40, height: 40 }); // percentage
  const [startTime, setStartTime] = useState(0);
  const [endTime, setEndTime] = useState(0);
  const [videoTintColor, setVideoTintColor] = useState<string | null>(null);
  const [currentVideoTime, setCurrentVideoTime] = useState(0);
  const [videoTintOpacity, setVideoTintOpacity] = useState(1);
  const [tintPosition, setTintPosition] = useState({ x: 50, y: 50 }); // percentage
  const [tintSize, setTintSize] = useState({ width: 100, height: 100 }); // percentage
  const [tintInvert, setTintInvert] = useState(false);
  const [isEditingTintArea, setIsEditingTintArea] = useState(false);
  const [isTintSectionOpen, setIsTintSectionOpen] = useState(false);
  const [isTextStylingSectionOpen, setIsTextStylingSectionOpen] =
    useState(false);
  const [isSoundSectionOpen, setIsSoundSectionOpen] = useState(false);
  const [isAnimationSectionOpen, setIsAnimationSectionOpen] = useState(false);

  const animationLabel = useMemo(() => {
    const labels: Record<OverlayAnimation, string> = {
      none: 'None',
      bounceIn: 'Bounce In',
      spring: 'Spring',
      fadeIn: 'Fade In',
      miniZoom: 'Mini Zoom',
      zoomIn: 'Zoom In',
      slideLeft: 'Slide Left',
      slideRight: 'Slide Right',
      slideUp: 'Slide Up',
    };
    return labels[overlayAnimation] ?? overlayAnimation;
  }, [overlayAnimation]);
  const tintPalette = useMemo(
    () => [
      '#000000',
      '#FFFFFF',
      '#DDC57A',
      '#00FF00',
      '#0000FF',
      '#FFFF00',
      '#FF00FF',
      '#00FFFF',
      '#FFA500',
    ],
    []
  );
  const [, setIsDragging] = useState(false);
  const [, setIsResizing] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [transcriptionWords, setTranscriptionWords] = useState<
    TranscriptionWord[] | null
  >(null);
  const [selectedWordText, setSelectedWordText] = useState<string | null>(null);
  const [customText, setCustomText] = useState<string>('');
  const [textOverlayPosition, setTextOverlayPosition] = useState({
    x: 50,
    y: 50,
  }); // percentage

  useEffect(() => {
    if (!isOpen) return;
    let cancelled = false;
    (async () => {
      try {
        const res = await fetch('/api/list-sounds');
        const data = (await res.json()) as {
          sounds?: { name: string; url: string }[];
        };
        if (cancelled) return;
        setAvailableSounds(Array.isArray(data.sounds) ? data.sounds : []);
      } catch {
        if (cancelled) return;
        setAvailableSounds([]);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [isOpen]);
  const [textOverlaySize, setTextOverlaySize] = useState({
    width: 100,
    height: 100,
  }); // percentage
  const [textStyling, setTextStyling] = useState<TextStyling>(() => {
    // Load default styling from localStorage, or use fallback defaults
    const saved = localStorage.getItem('defaultTextStyling');
    return saved
      ? JSON.parse(saved)
      : {
          fontColor: '#ffffff',
          borderWidth: 3,
          borderColor: '#000000',
          shadowX: 8,
          shadowY: 8,
          shadowColor: '#000000',
          shadowOpacity: 0.9,
          fontFamily: 'Helvetica',
          // Background (box) settings for text overlay
          bgColor: '#000000',
          bgOpacity: 0.65,
          bgSize: 8, // px padding for background around text
        };
  });
  // Saved text styling presets, persisted in localStorage
  const [savedTextStyles, setSavedTextStyles] = useState<
    { name: string; style: TextStyling }[]
  >([]);
  const [isFontLoaded, setIsFontLoaded] = useState<boolean>(false);
  const [showFontPreview, setShowFontPreview] = useState<boolean>(false);

  // Load saved styles from localStorage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem('savedTextStyles');
      if (stored) {
        console.log('Loading savedTextStyles from localStorage:', stored);
        const parsed = JSON.parse(stored) as {
          name: string;
          style: TextStyling;
        }[];
        setSavedTextStyles(parsed);
      }
    } catch (e) {
      console.error('Failed to load saved text styles:', e);
    }
  }, []);

  // Check whether the selected font family is loaded by the browser for live preview
  useEffect(() => {
    const family = textStyling.fontFamily;
    if (!family || typeof document === 'undefined' || !document.fonts) {
      setIsFontLoaded(false);
      return;
    }

    // Check if the font is available already
    (async () => {
      try {
        // Try to load a tiny variation and check if loaded
        await document.fonts.load(`12px "${family}"`);
        const loaded = document.fonts.check(`12px "${family}"`);
        setIsFontLoaded(loaded);
      } catch {
        setIsFontLoaded(false);
      }
    })();
  }, [textStyling.fontFamily]);

  // Build a list of fonts from the JSON mapping and fall back to a small default set
  const availableFontFamilies = useMemo(() => {
    const mapping = ffmpegFonts as Record<string, string>;
    const keys = Object.keys(mapping || {}).filter(
      (k) => k !== 'user_fonts_dir'
    );
    if (keys.length > 0) return keys.sort();
    // fallback:
    return ['Helvetica', 'Arial', 'Courier', 'Times', 'Menlo'];
  }, []);

  // Previously we wrote savedTextStyles on every state change, which could
  // overwrite loaded values on mount due to timing; we now only write to
  // localStorage explicitly when saving/deleting presets so we avoid race conditions.

  const saveCurrentTextStyle = useCallback(() => {
    const name = prompt('Enter a name for this text style preset');
    if (!name) return;
    // avoid duplicates
    if (savedTextStyles.some((s) => s.name === name)) {
      alert('A preset with that name already exists');
      return;
    }
    console.log('Saving preset', name, textStyling);
    setSavedTextStyles((prev) => {
      const next = [...prev, { name, style: textStyling }];
      try {
        localStorage.setItem('savedTextStyles', JSON.stringify(next));
        console.log('Saved preset to localStorage', next);
      } catch (e) {
        console.error('Failed to persist savedTextStyles during save', e);
      }
      return next;
    });
  }, [savedTextStyles, textStyling]);

  const applySavedTextStyle = useCallback(
    (preset: { name: string; style: TextStyling }) => {
      setTextStyling(preset.style);
    },
    []
  );

  const deleteSavedTextStyle = useCallback((name: string) => {
    if (!confirm(`Delete preset ${name}?`)) return;
    setSavedTextStyles((prev) => {
      const next = prev.filter((s) => s.name !== name);
      try {
        localStorage.setItem('savedTextStyles', JSON.stringify(next));
        console.log('Updated localStorage after delete', next);
      } catch (e) {
        console.error('Failed to persist savedTextStyles during delete', e);
      }
      return next;
    });
  }, []);
  const [, setIsDraggingText] = useState(false);
  const [, setIsResizingText] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [refetchTrigger, setRefetchTrigger] = useState(0);
  const [containerRect, setContainerRect] = useState<{
    width: number;
    height: number;
  } | null>(null);
  const [videoToCssScale, setVideoToCssScale] = useState(1);

  // Cropping state
  const [isCropping, setIsCropping] = useState(false);
  const cropperRef = useRef<CropperRef>(null);
  const [cropperModalKey, setCropperModalKey] = useState(0);
  const [cropBorderRadius, setCropBorderRadius] = useState(0);
  const [cropShape, setCropShape] = useState<CropShape>('rectangle');
  const [cropRotationDegrees, setCropRotationDegrees] = useState(0);

  const [cropEditorMode, setCropEditorMode] = useState<CropEditorMode>('crop');
  const [cropAdjustments, setCropAdjustments] = useState<CropAdjustments>({
    brightness: 0,
    contrast: 0,
    saturation: 0,
    hue: 0,
  });

  const isGifOverlay = overlayImage?.type === 'image/gif';

  const setCropRotationAbsolute = useCallback((nextDegrees: number) => {
    const next = Math.max(-180, Math.min(180, Math.round(nextDegrees)));
    const cropper = cropperRef.current;
    if (!cropper) {
      setCropRotationDegrees(next);
      return;
    }

    const current = cropper.getTransforms()?.rotate ?? 0;
    cropper.rotateImage(next - current);
    setCropRotationDegrees(next);
  }, []);

  // Safari needs a polyfill for CanvasRenderingContext2D.filter.
  useEffect(() => {
    if (typeof window === 'undefined') return;
    void import('context-filter-polyfill').catch(() => {
      // ignore
    });
  }, []);

  // Border radius isn't reliably supported for GIF output; keep it disabled.
  useEffect(() => {
    if (isGifOverlay) {
      setCropBorderRadius(0);
      setCropShape('rectangle');
      setCropRotationDegrees(0);
      setCropEditorMode('crop');
      setCropAdjustments({
        brightness: 0,
        contrast: 0,
        saturation: 0,
        hue: 0,
      });
    }
  }, [isGifOverlay]);

  useEffect(() => {
    if (cropShape === 'circle') {
      setCropBorderRadius(0);
    }
  }, [cropShape]);

  // Actual image dimensions in pixels
  const [actualImageDimensions, setActualImageDimensions] = useState<{
    width: number;
    height: number;
  } | null>(null);

  // Store the original video URL when the modal opens
  const [originalVideoUrl, setOriginalVideoUrl] = useState<string | null>(null);

  const videoRef = useRef<HTMLVideoElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null!);
  const previewVideoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (!isOpen) return;
    const video = videoRef.current;
    if (!video) return;

    const update = () => setCurrentVideoTime(video.currentTime || 0);
    video.addEventListener('timeupdate', update);
    video.addEventListener('seeked', update);
    update();

    return () => {
      video.removeEventListener('timeupdate', update);
      video.removeEventListener('seeked', update);
    };
  }, [isOpen, originalVideoUrl]);

  const isTintActive =
    !!videoTintColor &&
    Number.isFinite(startTime) &&
    Number.isFinite(endTime) &&
    currentVideoTime >= startTime &&
    currentVideoTime <= endTime;

  const shouldShowTintOverlay =
    !!videoTintColor && (isTintActive || isEditingTintArea);

  const tintRect = useMemo(() => {
    const clampPct = (v: number) => Math.max(0, Math.min(100, v));
    const safeW = Math.max(0, Math.min(100, tintSize.width));
    const safeH = Math.max(0, Math.min(100, tintSize.height));
    const left = clampPct(tintPosition.x - safeW / 2);
    const top = clampPct(tintPosition.y - safeH / 2);
    const right = clampPct(tintPosition.x + safeW / 2);
    const bottom = clampPct(tintPosition.y + safeH / 2);
    return {
      left,
      top,
      right,
      bottom,
      width: Math.max(0, right - left),
      height: Math.max(0, bottom - top),
    };
  }, [tintPosition, tintSize]);

  const clamp01 = useCallback((v: number) => Math.max(0, Math.min(1, v)), []);

  // Keep a scale factor so CSS preview sizes (px) match FFmpeg drawtext sizes (video px).
  // Example: borderw=3 in FFmpeg should appear as ~3px on the source video, which is
  // borderw * (displayedVideoPx / sourceVideoPx) in the browser preview.
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const rect = containerRect ?? video.getBoundingClientRect();
    if (!rect?.width || !rect?.height) return;
    if (!video.videoWidth || !video.videoHeight) return;

    const scaleX = rect.width / video.videoWidth;
    const scaleY = rect.height / video.videoHeight;
    const next = Math.min(scaleX, scaleY);
    if (Number.isFinite(next) && next > 0) setVideoToCssScale(next);
  }, [containerRect, originalVideoUrl]);

  const getVideoContentRect = useCallback(() => {
    const video = videoRef.current;
    if (!video) return null;

    // Use the video element's rect for overlay positioning
    const rect = video.getBoundingClientRect();
    return rect;
  }, []);

  const getVideoNaturalDimensions = useCallback(() => {
    const video = videoRef.current;
    const vw = video?.videoWidth;
    const vh = video?.videoHeight;
    return {
      videoWidth: typeof vw === 'number' && vw > 0 ? vw : 1920,
      videoHeight: typeof vh === 'number' && vh > 0 ? vh : 1080,
    };
  }, []);

  const setOverlaySizeFromPixels = useCallback(
    (w: number, h: number) => {
      const { videoWidth, videoHeight } = getVideoNaturalDimensions();
      const widthPercent = (w / videoWidth) * 100;
      const heightPercent = (h / videoHeight) * 100;
      setOverlaySize({
        width: Math.min(widthPercent, 100),
        height: Math.min(heightPercent, 100),
      });
    },
    [getVideoNaturalDimensions, setOverlaySize]
  );

  const handleOverlayWheelZoom = useCallback(
    (e: React.WheelEvent) => {
      // Ignore browser pinch-zoom (trackpad pinch typically sets ctrlKey=true on macOS).
      if (e.ctrlKey) return;

      e.preventDefault();
      e.stopPropagation();

      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      setOverlaySize((prev) => ({
        width: Math.min(100, Math.max(5, prev.width * factor)),
        height: Math.min(100, Math.max(5, prev.height * factor)),
      }));
    },
    [setOverlaySize]
  );

  const handleTextOverlayWheelZoom = useCallback(
    (e: React.WheelEvent) => {
      if (e.ctrlKey) return;

      e.preventDefault();
      e.stopPropagation();

      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      setTextOverlaySize((prev) => ({
        width: Math.min(100, Math.max(5, prev.width * factor)),
        height: Math.min(100, Math.max(5, prev.height * factor)),
      }));
    },
    [setTextOverlaySize]
  );

  const ensureOverlayImageDimensions = useCallback(async () => {
    if (actualImageDimensions) return actualImageDimensions;
    if (!overlayImageUrl) return null;

    const img = new Image();
    img.src = overlayImageUrl;
    try {
      // decode() is more reliable than onload timing for some images
      if (typeof img.decode === 'function') {
        await img.decode();
      } else {
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = () => reject(new Error('Failed to load image'));
        });
      }
    } catch {
      return null;
    }

    if (!(img.width > 0 && img.height > 0)) return null;
    const dims = { width: img.width, height: img.height };
    setActualImageDimensions(dims);
    return dims;
  }, [actualImageDimensions, overlayImageUrl]);

  const handleImageUpload = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (file && file.type.startsWith('image/')) {
        setOverlayImage(file);
        const url = URL.createObjectURL(file);
        setOverlayImageUrl(url);
        // Clear text overlay when adding image
        setSelectedWordText(null);
        setCustomText('');

        const img = new Image();
        img.onload = () => {
          setActualImageDimensions({ width: img.width, height: img.height });
          setOverlaySizeFromPixels(img.width, img.height);
        };
        img.src = url;
      }
    },
    [setOverlaySizeFromPixels]
  );

  const handleRemoveImage = useCallback(() => {
    setOverlayImage(null);
    setOverlayImageUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, []);

  const handleScreenshot = useCallback(() => {
    const video = videoRef.current;
    if (!video) return;

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      canvas.toBlob((blob) => {
        if (blob) {
          const file = new File([blob], 'screenshot.png', {
            type: 'image/png',
          });
          setOverlayImage(file);
          const url = URL.createObjectURL(file);
          setOverlayImageUrl(url);
          // Clear text overlay when adding image
          setSelectedWordText(null);
          setCustomText('');

          setActualImageDimensions({
            width: canvas.width,
            height: canvas.height,
          });
          setOverlaySizeFromPixels(canvas.width, canvas.height);
        }
      }, 'image/png');
    }
  }, [setOverlaySizeFromPixels]);

  const handleCopyOverlayImageToClipboard = useCallback(async () => {
    if (!overlayImage) return;

    try {
      const clipboard = navigator.clipboard;
      type ClipboardItemConstructor = new (
        items: Record<string, Blob>
      ) => ClipboardItem;
      const ClipboardItemCtor = (
        window as unknown as {
          ClipboardItem?: ClipboardItemConstructor;
        }
      ).ClipboardItem;

      if (!clipboard?.write || !ClipboardItemCtor) {
        alert('Copying images to clipboard is not supported in this browser.');
        return;
      }

      const mime = overlayImage.type || 'image/png';
      await clipboard.write([
        new ClipboardItemCtor({
          [mime]: overlayImage,
        }),
      ]);
    } catch (e) {
      console.error('Failed to copy overlay image to clipboard:', e);
      alert(
        'Failed to copy image to clipboard. Your browser may be blocking clipboard access.'
      );
    }
  }, [overlayImage]);

  const handlePasteOverlayImageFromClipboard = useCallback(async () => {
    try {
      const clipboard = navigator.clipboard;
      if (!clipboard) {
        alert('Clipboard is not available in this browser.');
        return;
      }

      // Some browsers can lose “user activation” after awaiting other clipboard
      // operations; start readText() immediately so it stays tied to the click.
      const textPromise: Promise<string | null> = clipboard.readText
        ? clipboard.readText().catch(() => null)
        : Promise.resolve(null);
      const setOverlayFromFile = (file: File) => {
        setOverlayImage(file);
        const url = URL.createObjectURL(file);
        setOverlayImageUrl(url);

        // Clear text overlay when adding image
        setSelectedWordText(null);
        setCustomText('');

        // Calculate overlay size similarly to upload/screenshot
        const img = new Image();
        img.onload = () => {
          setActualImageDimensions({ width: img.width, height: img.height });
          setOverlaySizeFromPixels(img.width, img.height);
        };
        img.src = url;
      };

      const extractFirstUrl = (text: string): string | null => {
        const trimmed = text.trim();
        if (!trimmed) return null;

        // Handle data URLs
        if (trimmed.startsWith('data:image/')) return trimmed;

        // Extract first http(s) URL from any text blob
        const m = trimmed.match(/https?:\/\/[^\s"'<>]+/i);
        return m ? m[0] : null;
      };

      const fetchImageAsFile = async (url: string): Promise<File | null> => {
        const res = await fetch(
          `/api/fetch-image?url=${encodeURIComponent(url)}`
        );
        if (!res.ok) {
          // Try to surface server error JSON if present
          let message = `Failed to fetch image URL (${res.status})`;
          try {
            const j = (await res.json()) as { error?: string };
            if (j?.error) message = j.error;
          } catch {
            // ignore
          }

          // If the URL resolves but is not an image (e.g. video/mp4), silently ignore.
          if (/did not return an image|content-type/i.test(message)) {
            return null;
          }

          throw new Error(message);
        }

        const blob = await res.blob();
        if (blob.type && !blob.type.startsWith('image/')) {
          return null;
        }
        const type = blob.type || 'image/png';
        const ext = type.split('/')[1] || 'png';
        return new File([blob], `pasted-url-image.${ext}`, { type });
      };

      // 1) Prefer true clipboard image blobs when available
      if (clipboard?.read) {
        const items = await clipboard.read();
        for (const item of items) {
          const t = (item.types || []).find((x) => x.startsWith('image/'));
          if (!t) continue;
          const imageBlob = await item.getType(t);
          const ext = t.split('/')[1] || 'png';
          setOverlayFromFile(
            new File([imageBlob], `clipboard-image.${ext}`, { type: t })
          );
          return;
        }

        // 2) If clipboard includes HTML, try extracting <img src="...">
        for (const item of items) {
          if (!item.types?.includes('text/html')) continue;
          const htmlBlob = await item.getType('text/html');
          const html = await htmlBlob.text();
          const srcMatch = html.match(/<img[^>]+src=["']([^"']+)["']/i);
          const src = srcMatch?.[1] ? extractFirstUrl(srcMatch[1]) : null;
          if (src) {
            const file = src.startsWith('data:image/')
              ? (() => {
                  return fetch(src)
                    .then((r) => r.blob())
                    .then((blob) => {
                      const type = blob.type || 'image/png';
                      const ext = type.split('/')[1] || 'png';
                      return new File([blob], `pasted-html-image.${ext}`, {
                        type,
                      });
                    });
                })()
              : fetchImageAsFile(src);
            const resolved = await file;
            if (!resolved) return;
            setOverlayFromFile(resolved);
            return;
          }
        }
      }

      // 3) Fall back to text (URL) paste
      const text = await textPromise;
      const maybeUrl = text ? extractFirstUrl(text) : null;
      if (!maybeUrl) {
        const manual = prompt(
          'Clipboard access was blocked or did not contain an image.\nPaste an image URL instead:'
        );
        const manualUrl = manual ? extractFirstUrl(manual) : null;
        if (!manualUrl) {
          alert('No image URL provided.');
          return;
        }

        if (manualUrl.startsWith('data:image/')) {
          const blob = await (await fetch(manualUrl)).blob();
          const type = blob.type || 'image/png';
          const ext = type.split('/')[1] || 'png';
          setOverlayFromFile(
            new File([blob], `pasted-data-image.${ext}`, { type })
          );
          return;
        }

        const file = await fetchImageAsFile(manualUrl);
        if (!file) return;
        setOverlayFromFile(file);
        return;
      }

      if (maybeUrl.startsWith('data:image/')) {
        const blob = await (await fetch(maybeUrl)).blob();
        const type = blob.type || 'image/png';
        const ext = type.split('/')[1] || 'png';
        setOverlayFromFile(
          new File([blob], `pasted-data-image.${ext}`, { type })
        );
        return;
      }

      // http(s) URL
      const file = await fetchImageAsFile(maybeUrl);
      if (!file) return;
      setOverlayFromFile(file);
    } catch (e) {
      // Avoid noisy console errors; show a user-facing message only.
      alert(
        'Failed to paste image from clipboard. Your browser may be blocking clipboard access.'
      );
    }
  }, []);

  const applyCrop = useCallback(async () => {
    console.log('applyCrop called');
    if (!cropperRef.current || !overlayImageUrl) {
      console.log('Missing cropperRef.current or overlayImageUrl');
      return;
    }

    const coordinates = cropperRef.current.getCoordinates();
    const canvas = cropperRef.current.getCanvas();

    console.log('Coordinates:', coordinates);
    console.log('Canvas:', canvas);

    if (!coordinates || !canvas) {
      console.log('Missing coordinates or canvas');
      return;
    }

    const applyCroppedFile = (croppedFile: File, w: number, h: number) => {
      const croppedUrl = URL.createObjectURL(croppedFile);

      setOverlayImage(croppedFile);
      setOverlayImageUrl(croppedUrl);

      setActualImageDimensions({ width: w, height: h });

      // Auto-reset overlay size to cropped image natural size
      setOverlayPosition({ x: 50, y: 50 });
      setOverlaySizeFromPixels(w, h);

      setIsCropping(false);
      console.log('Crop applied successfully');
    };

    // If the overlay is an animated GIF, canvas cropping will freeze it.
    // For GIFs, crop server-side with FFmpeg to preserve animation.
    if (overlayImage?.type === 'image/gif') {
      const left = Math.round(coordinates.left);
      const top = Math.round(coordinates.top);
      const width = Math.round(coordinates.width);
      const height = Math.round(coordinates.height);

      const form = new FormData();
      form.append('image', overlayImage);
      form.append('left', String(Math.max(0, left)));
      form.append('top', String(Math.max(0, top)));
      form.append('width', String(Math.max(1, width)));
      form.append('height', String(Math.max(1, height)));

      const res = await fetch('/api/crop-gif', { method: 'POST', body: form });
      if (!res.ok) {
        let message = `Failed to crop GIF (${res.status})`;
        try {
          const j = (await res.json()) as { error?: string };
          if (j?.error) message = j.error;
        } catch {
          // ignore
        }
        alert(message);
        return;
      }

      const blob = await res.blob();
      const file = new File([blob], 'cropped-image.gif', { type: 'image/gif' });
      applyCroppedFile(file, Math.max(1, width), Math.max(1, height));
      return;
    }

    // Convert canvas to blob (non-GIF)
    const outCanvas =
      cropShape === 'circle'
        ? circleCanvasFromSource(canvas)
        : roundedCanvasFromSource(canvas, cropBorderRadius);
    outCanvas.toBlob((blob) => {
      if (blob) {
        console.log('Blob created, size:', blob.size);
        const croppedFile = new File([blob], 'cropped-image.png', {
          type: 'image/png',
        });
        applyCroppedFile(croppedFile, coordinates.width, coordinates.height);
      } else {
        console.log('Failed to create blob');
      }
    }, 'image/png');
  }, [cropperRef, overlayImageUrl, overlayImage, cropBorderRadius, cropShape]);

  const handleVideoLoad = useCallback(() => {
    const video = videoRef.current;
    if (video && video.duration) {
      setEndTime(video.duration);

      // Update container rect when video loads
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    }
  }, [getVideoContentRect]);

  // Ensure video element updates when videoUrl changes
  useEffect(() => {
    const video = videoRef.current;
    if (video && originalVideoUrl && video.src !== originalVideoUrl) {
      video.src = originalVideoUrl;
      video.load();
    }
  }, [originalVideoUrl]);

  const handleMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!overlayImageUrl) return;

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if clicking on the overlay image
      const overlayX = overlayPosition.x - overlaySize.width / 2;
      const overlayY = overlayPosition.y - overlaySize.height / 2;

      // Convert to pixels
      const overlayX_px = (overlayX / 100) * contentRect.width;
      const overlayY_px = (overlayY / 100) * contentRect.height;
      const overlayWidth_px = (overlaySize.width / 100) * contentRect.width;
      const overlayHeight_px = (overlaySize.height / 100) * contentRect.height;

      // Check if clicking near edges/corners for resizing (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= overlayX_px - edgeThreshold && x <= overlayX_px + edgeThreshold;
      const nearRightEdge =
        x >= overlayX_px + overlayWidth_px - edgeThreshold &&
        x <= overlayX_px + overlayWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= overlayY_px - edgeThreshold && y <= overlayY_px + edgeThreshold;
      const nearBottomEdge =
        y >= overlayY_px + overlayHeight_px - edgeThreshold &&
        y <= overlayY_px + overlayHeight_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      if (isNearEdge) {
        // Start resizing - determine resize direction based on which edges are near
        const startX = event.clientX;
        const startY = event.clientY;
        const startSize = { ...overlaySize };
        const startPos = { ...overlayPosition };
        const pointerId = event.pointerId;

        setIsResizing(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          // Allow free resizing without maintaining aspect ratio
          // Handle horizontal resizing
          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2; // Move position to keep right edge in place
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width + deltaX);
          }

          // Handle vertical resizing
          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2; // Move position to keep bottom edge in place
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height + deltaY);
          }

          setOverlaySize({
            width: Math.min(newWidth, 100),
            height: Math.min(newHeight, 100),
          });

          // Update position if resizing from top/left
          if (nearLeftEdge || nearTopEdge) {
            setOverlayPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          setIsResizing(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      } else if (
        x >= overlayX_px &&
        x <= overlayX_px + overlayWidth_px &&
        y >= overlayY_px &&
        y <= overlayY_px + overlayHeight_px
      ) {
        // Start dragging (center area)
        const startX = event.clientX;
        const startY = event.clientY;
        const startPos = { ...overlayPosition };
        const pointerId = event.pointerId;

        setIsDragging(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;

          setOverlayPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          setIsDragging(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [overlayImageUrl, overlayPosition, overlaySize, getVideoContentRect]
  );

  const handleTextMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!selectedWordText) return;

      const contentRect = containerRect
        ? {
            width: containerRect.width,
            height: containerRect.height,
            left: 0,
            top: 0,
          }
        : getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if clicking on the text overlay (calculate based on text content using percentages)
      const textWidthPercent = Math.min(
        95,
        (selectedWordText.length <= 3
          ? 35
          : selectedWordText.length <= 7
          ? 55
          : selectedWordText.length <= 12
          ? 70
          : 85) *
          (textOverlaySize.width / 20)
      );
      const textHeightPercent = Math.max(
        10,
        Math.min(85, (textOverlaySize.width / 100) * 60)
      );
      const textX = textOverlayPosition.x - textWidthPercent / 2;
      const textY = textOverlayPosition.y - textHeightPercent / 2;

      // Convert to pixels
      const textX_px = (textX / 100) * contentRect.width;
      const textY_px = (textY / 100) * contentRect.height;
      const textWidth_px = (textWidthPercent / 100) * contentRect.width;
      const textHeight_px = (textHeightPercent / 100) * contentRect.height;

      // Check if clicking near edges/corners for resizing (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= textX_px - edgeThreshold && x <= textX_px + edgeThreshold;
      const nearRightEdge =
        x >= textX_px + textWidth_px - edgeThreshold &&
        x <= textX_px + textWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= textY_px - edgeThreshold && y <= textY_px + edgeThreshold;
      const nearBottomEdge =
        y >= textY_px + textHeight_px - edgeThreshold &&
        y <= textY_px + textHeight_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      if (isNearEdge) {
        // Start resizing - determine resize direction based on which edges are near
        const startX = event.clientX;
        const startY = event.clientY;
        const startSize = { ...textOverlaySize };
        const startPos = { ...textOverlayPosition };
        const pointerId = event.pointerId;

        setIsResizingText(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          // Handle horizontal resizing
          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2; // Move position to keep right edge in place
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(5, startSize.width + deltaX);
          }

          // Handle vertical resizing
          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2; // Move position to keep bottom edge in place
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(5, startSize.height + deltaY);
          }

          setTextOverlaySize({
            width: Math.min(newWidth, 100),
            height: Math.min(newHeight, 100),
          });

          // Update position if resizing from top/left
          if (nearLeftEdge || nearTopEdge) {
            setTextOverlayPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          setIsResizingText(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      } else if (
        x >= textX_px &&
        x <= textX_px + textWidth_px &&
        y >= textY_px &&
        y <= textY_px + textHeight_px
      ) {
        // Start dragging (center area)
        const startX = event.clientX;
        const startY = event.clientY;
        const startPos = { ...textOverlayPosition };
        const pointerId = event.pointerId;

        setIsDraggingText(true);

        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;

          setTextOverlayPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          setIsDraggingText(false);
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          // Release pointer capture
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore errors if pointer capture wasn't set
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        // Capture pointer to ensure mouse events are received even outside the element
        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [
      selectedWordText,
      textOverlayPosition,
      textOverlaySize,
      getVideoContentRect,
      containerRect,
    ]
  );

  const handlePointerMove = useCallback(
    (event: React.PointerEvent) => {
      if (!overlayImageUrl) return;

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      // Check if hovering near edges/corners for resizing
      const overlayX = overlayPosition.x - overlaySize.width / 2;
      const overlayY = overlayPosition.y - overlaySize.height / 2;

      // Convert to pixels
      const overlayX_px = (overlayX / 100) * contentRect.width;
      const overlayY_px = (overlayY / 100) * contentRect.height;
      const overlayWidth_px = (overlaySize.width / 100) * contentRect.width;
      const overlayHeight_px = (overlaySize.height / 100) * contentRect.height;

      // Check if hovering near edges/corners (within 10px of edges)
      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= overlayX_px - edgeThreshold && x <= overlayX_px + edgeThreshold;
      const nearRightEdge =
        x >= overlayX_px + overlayWidth_px - edgeThreshold &&
        x <= overlayX_px + overlayWidth_px + edgeThreshold;
      const nearTopEdge =
        y >= overlayY_px - edgeThreshold && y <= overlayY_px + edgeThreshold;
      const nearBottomEdge =
        y >= overlayY_px + overlayHeight_px - edgeThreshold &&
        y <= overlayY_px + overlayHeight_px + edgeThreshold;

      // Set cursor based on position
      if (nearLeftEdge && nearTopEdge) {
        document.body.style.cursor = 'nw-resize';
      } else if (nearRightEdge && nearTopEdge) {
        document.body.style.cursor = 'ne-resize';
      } else if (nearLeftEdge && nearBottomEdge) {
        document.body.style.cursor = 'sw-resize';
      } else if (nearRightEdge && nearBottomEdge) {
        document.body.style.cursor = 'se-resize';
      } else if (nearLeftEdge || nearRightEdge) {
        document.body.style.cursor = 'ew-resize';
      } else if (nearTopEdge || nearBottomEdge) {
        document.body.style.cursor = 'ns-resize';
      } else if (
        x >= overlayX_px &&
        x <= overlayX_px + overlayWidth_px &&
        y >= overlayY_px &&
        y <= overlayY_px + overlayHeight_px
      ) {
        document.body.style.cursor = 'move';
      } else {
        document.body.style.cursor = 'default';
      }
    },
    [overlayImageUrl, overlayPosition, overlaySize, getVideoContentRect]
  );

  const handlePointerLeave = useCallback(() => {
    document.body.style.cursor = 'default';
  }, []);

  const handleTintMouseDown = useCallback(
    (event: React.PointerEvent) => {
      if (!isEditingTintArea) return;

      event.stopPropagation();

      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      const rectLeft_px = (tintRect.left / 100) * contentRect.width;
      const rectTop_px = (tintRect.top / 100) * contentRect.height;
      const rectW_px = (tintRect.width / 100) * contentRect.width;
      const rectH_px = (tintRect.height / 100) * contentRect.height;

      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= rectLeft_px - edgeThreshold && x <= rectLeft_px + edgeThreshold;
      const nearRightEdge =
        x >= rectLeft_px + rectW_px - edgeThreshold &&
        x <= rectLeft_px + rectW_px + edgeThreshold;
      const nearTopEdge =
        y >= rectTop_px - edgeThreshold && y <= rectTop_px + edgeThreshold;
      const nearBottomEdge =
        y >= rectTop_px + rectH_px - edgeThreshold &&
        y <= rectTop_px + rectH_px + edgeThreshold;

      const isNearEdge =
        nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge;

      const startX = event.clientX;
      const startY = event.clientY;
      const startSize = { ...tintSize };
      const startPos = { ...tintPosition };
      const pointerId = event.pointerId;

      const minSizePct = 5;

      if (isNearEdge) {
        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;

          let newWidth = startSize.width;
          let newHeight = startSize.height;
          let newX = startPos.x;
          let newY = startPos.y;

          if (nearLeftEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(minSizePct, startSize.width - deltaX);
            newX = startPos.x + deltaX / 2;
          } else if (nearRightEdge) {
            const deltaX = ((e.clientX - startX) / rect.width) * 100;
            newWidth = Math.max(minSizePct, startSize.width + deltaX);
          }

          if (nearTopEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(minSizePct, startSize.height - deltaY);
            newY = startPos.y + deltaY / 2;
          } else if (nearBottomEdge) {
            const deltaY = ((e.clientY - startY) / rect.height) * 100;
            newHeight = Math.max(minSizePct, startSize.height + deltaY);
          }

          setTintSize({
            width: Math.min(100, Math.max(minSizePct, newWidth)),
            height: Math.min(100, Math.max(minSizePct, newHeight)),
          });

          if (nearLeftEdge || nearTopEdge) {
            setTintPosition({
              x: Math.max(0, Math.min(100, newX)),
              y: Math.max(0, Math.min(100, newY)),
            });
          }
        };

        const handleGlobalPointerUp = () => {
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
        return;
      }

      // Drag when clicking inside the rect
      if (
        x >= rectLeft_px &&
        x <= rectLeft_px + rectW_px &&
        y >= rectTop_px &&
        y <= rectTop_px + rectH_px
      ) {
        const handleGlobalPointerMove = (e: PointerEvent) => {
          const rect = getVideoContentRect();
          if (!rect) return;
          const deltaX = ((e.clientX - startX) / rect.width) * 100;
          const deltaY = ((e.clientY - startY) / rect.height) * 100;
          setTintPosition({
            x: Math.max(0, Math.min(100, startPos.x + deltaX)),
            y: Math.max(0, Math.min(100, startPos.y + deltaY)),
          });
        };

        const handleGlobalPointerUp = () => {
          document.removeEventListener('pointermove', handleGlobalPointerMove);
          document.removeEventListener('pointerup', handleGlobalPointerUp);
          try {
            (event.target as Element)?.releasePointerCapture(pointerId);
          } catch {
            // Ignore
          }
        };

        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);

        (event.target as Element).setPointerCapture(event.pointerId);
        event.preventDefault();
      }
    },
    [
      getVideoContentRect,
      isEditingTintArea,
      tintPosition,
      tintRect.bottom,
      tintRect.height,
      tintRect.left,
      tintRect.right,
      tintRect.top,
      tintRect.width,
      tintSize,
    ]
  );

  const handleTintPointerMove = useCallback(
    (event: React.PointerEvent) => {
      if (!isEditingTintArea) return;
      const contentRect = getVideoContentRect();
      if (!contentRect) return;

      const x = event.clientX - contentRect.left;
      const y = event.clientY - contentRect.top;

      const rectLeft_px = (tintRect.left / 100) * contentRect.width;
      const rectTop_px = (tintRect.top / 100) * contentRect.height;
      const rectW_px = (tintRect.width / 100) * contentRect.width;
      const rectH_px = (tintRect.height / 100) * contentRect.height;

      const edgeThreshold = 10;
      const nearLeftEdge =
        x >= rectLeft_px - edgeThreshold && x <= rectLeft_px + edgeThreshold;
      const nearRightEdge =
        x >= rectLeft_px + rectW_px - edgeThreshold &&
        x <= rectLeft_px + rectW_px + edgeThreshold;
      const nearTopEdge =
        y >= rectTop_px - edgeThreshold && y <= rectTop_px + edgeThreshold;
      const nearBottomEdge =
        y >= rectTop_px + rectH_px - edgeThreshold &&
        y <= rectTop_px + rectH_px + edgeThreshold;

      if (nearLeftEdge && nearTopEdge) {
        document.body.style.cursor = 'nw-resize';
      } else if (nearRightEdge && nearTopEdge) {
        document.body.style.cursor = 'ne-resize';
      } else if (nearLeftEdge && nearBottomEdge) {
        document.body.style.cursor = 'sw-resize';
      } else if (nearRightEdge && nearBottomEdge) {
        document.body.style.cursor = 'se-resize';
      } else if (nearLeftEdge || nearRightEdge) {
        document.body.style.cursor = 'ew-resize';
      } else if (nearTopEdge || nearBottomEdge) {
        document.body.style.cursor = 'ns-resize';
      } else if (
        x >= rectLeft_px &&
        x <= rectLeft_px + rectW_px &&
        y >= rectTop_px &&
        y <= rectTop_px + rectH_px
      ) {
        document.body.style.cursor = 'move';
      } else {
        document.body.style.cursor = 'default';
      }
    },
    [getVideoContentRect, isEditingTintArea, tintRect]
  );

  const handlePreview = useCallback(async () => {
    if (!overlayImage && !selectedWordText && !videoTintColor) return;
    if (!originalVideoUrl) return;
    console.log('handlePreview: textStyling', textStyling);

    const formData = new FormData();
    formData.append('videoUrl', originalVideoUrl);
    formData.append('sceneId', sceneId.toString());
    if (overlayImage) {
      formData.append('overlayImage', overlayImage);
    }
    if (selectedWordText) {
      formData.append('overlayText', selectedWordText);
    }
    formData.append(
      'positionX',
      (overlayImage ? overlayPosition.x : textOverlayPosition.x).toString()
    );
    formData.append(
      'positionY',
      (overlayImage ? overlayPosition.y : textOverlayPosition.y).toString()
    );
    formData.append(
      'sizeWidth',
      (overlayImage ? overlaySize.width : textOverlaySize.width).toString()
    );
    formData.append(
      'sizeHeight',
      (overlayImage ? overlaySize.height : textOverlaySize.height).toString()
    );
    formData.append('startTime', startTime.toString());
    formData.append('endTime', endTime.toString());
    formData.append('preview', 'true');
    if (videoTintColor) {
      formData.append('videoTintColor', videoTintColor);
      formData.append('videoTintOpacity', clamp01(videoTintOpacity).toString());
      formData.append('videoTintPositionX', tintPosition.x.toString());
      formData.append('videoTintPositionY', tintPosition.y.toString());
      formData.append('videoTintWidth', tintSize.width.toString());
      formData.append('videoTintHeight', tintSize.height.toString());
      formData.append('videoTintInvert', tintInvert ? 'true' : 'false');
    }
    if (selectedSoundName) {
      formData.append('overlaySound', selectedSoundName);
    }
    formData.append('overlayAnimation', overlayAnimation);
    if (selectedWordText && textStyling) {
      formData.append('textStyling', JSON.stringify(textStyling));
    }

    try {
      const response = await fetch('/api/add-image-overlay', {
        method: 'POST',
        body: formData,
      });
      const data = await response.json();
      if (data.success) {
        setPreviewUrl(data.url);
      } else {
        alert('Preview failed: ' + data.error);
      }
    } catch {
      alert('Error generating preview');
    }
  }, [
    overlayImage,
    selectedWordText,
    videoTintColor,
    videoTintOpacity,
    originalVideoUrl,
    sceneId,
    overlayPosition,
    textOverlayPosition,
    overlaySize,
    textOverlaySize,
    startTime,
    endTime,
    textStyling,
    clamp01,
    tintInvert,
    tintPosition.x,
    tintPosition.y,
    tintSize.height,
    tintSize.width,
    selectedSoundName,
    overlayAnimation,
  ]);

  const handleApply = useCallback(async () => {
    if (!overlayImage && !selectedWordText && !videoTintColor) return;

    try {
      console.log(
        'handleApply: sending textStyling',
        selectedWordText ? textStyling : undefined
      );
      // Apply overlay to the CURRENT video playing in the modal
      await onApply(
        sceneId,
        overlayImage,
        selectedWordText,
        overlayImage ? overlayPosition : textOverlayPosition,
        overlayImage ? overlaySize : textOverlaySize,
        startTime,
        endTime,
        selectedWordText ? textStyling : undefined,
        videoTintColor,
        videoTintOpacity,
        tintPosition,
        tintSize,
        tintInvert,
        selectedSoundName,
        overlayAnimation
      );

      // After applying, fetch the scene from the DB to get the updated video URL
      // Retry a few times in case the DB update hasn't fully propagated
      const maxRetries = 6;
      let attempts = 0;
      let sceneData: { field_6886?: unknown } | null = null;
      let newUrl: string | undefined;
      while (attempts < maxRetries) {
        sceneData = (await getSceneById(sceneId)) as {
          field_6886?: unknown;
        } | null;
        newUrl =
          typeof sceneData?.field_6886 === 'string'
            ? sceneData.field_6886
            : undefined;
        if (newUrl && newUrl !== originalVideoUrl) break;
        await new Promise((res) => setTimeout(res, 500));
        attempts++;
      }

      if (newUrl) {
        setOriginalVideoUrl(newUrl);
        // Notify parent so subsequent applies use the new video URL
        if (onUpdateModalVideoUrl) {
          onUpdateModalVideoUrl(newUrl);
        }
      }

      // Force a refetch of transcription and other modal data
      // but avoid triggering this refetch during batch operations to prevent
      // per-loop data refreshes that lead to UI flicker.
      if (!useAppStore.getState().batchOperations.transcribingAllFinalScenes) {
        setRefetchTrigger((prev) => prev + 1);
      }

      // Reset overlay state to defaults (like opening a fresh modal) but keep it open
      setOverlayImage(null);
      setOverlayImageUrl(null);
      setOverlayPosition({ x: 50, y: 50 });
      setOverlaySize({ width: 40, height: 40 });
      setPreviewUrl(null);
      setSelectedWordText(null);
      setCustomText('');
      setStartTime(0);
      setEndTime(0);
      setVideoTintColor(null);
      setVideoTintOpacity(1);
      setTintPosition({ x: 50, y: 50 });
      setTintSize({ width: 100, height: 100 });
      setTintInvert(false);
      setIsEditingTintArea(false);
      setSelectedSoundName('pop.wav');
      setOverlayAnimation('miniZoom');
      setIsTintSectionOpen(false);
      setIsTextStylingSectionOpen(false);
      setIsSoundSectionOpen(false);
      setIsAnimationSectionOpen(false);
      setIsCropping(false);
      setActualImageDimensions(null);
      setTextOverlayPosition({ x: 50, y: 50 });
      setTextOverlaySize({ width: 100, height: 100 });
      setTextStyling(() => {
        const saved = localStorage.getItem('defaultTextStyling');
        return saved
          ? JSON.parse(saved)
          : {
              fontColor: '#ffffff',
              borderWidth: 3,
              borderColor: '#000000',
              shadowX: 8,
              shadowY: 8,
              shadowColor: '#000000',
              shadowOpacity: 0.9,
              fontFamily: 'Helvetica',
              bgColor: '#000000',
              bgOpacity: 0.65,
              bgSize: 8,
            };
      });
    } catch (error) {
      console.error('Failed to apply overlay and refresh modal:', error);
    }
  }, [
    overlayImage,
    selectedWordText,
    textStyling,
    videoTintColor,
    videoTintOpacity,
    tintInvert,
    tintPosition,
    tintSize,
    selectedSoundName,
    sceneId,
    overlayPosition,
    overlaySize,
    textOverlayPosition,
    textOverlaySize,
    startTime,
    endTime,
    overlayAnimation,
    onApply,
    onUpdateModalVideoUrl,
    originalVideoUrl,
  ]);

  const handleClose = useCallback(() => {
    onClose();
    // Reset state
    setOverlayImage(null);
    setOverlayImageUrl(null);
    setOverlayPosition({ x: 50, y: 50 });
    setOverlaySize({ width: 40, height: 40 });
    setStartTime(0);
    setEndTime(0);
    setVideoTintColor(null);
    setVideoTintOpacity(1);
    setTintPosition({ x: 50, y: 50 });
    setTintSize({ width: 100, height: 100 });
    setTintInvert(false);
    setIsEditingTintArea(false);
    setSelectedSoundName('pop.wav');
    setOverlayAnimation('miniZoom');
    setIsTintSectionOpen(false);
    setIsTextStylingSectionOpen(false);
    setIsSoundSectionOpen(false);
    setIsAnimationSectionOpen(false);
    setPreviewUrl(null);
    setTranscriptionWords(null);
    setSelectedWordText(null);
    setCustomText('');
    setSelectedWordText(null);
  }, [onClose]);

  // Fetch transcription data
  useEffect(() => {
    if (isOpen && sceneId) {
      setIsTintSectionOpen(false);
      setIsTextStylingSectionOpen(false);
      // Clear any leftover preview state when modal opens
      setPreviewUrl(null);
      // Set the original video URL when we have a valid video URL
      if (videoUrl && videoUrl.trim() !== '') {
        setOriginalVideoUrl(videoUrl);
      }

      const fetchTranscription = async () => {
        try {
          // Fetch scene data from Baserow to get the Captions URL
          const sceneData = await getSceneById(sceneId);

          // Try different possible field names and specific field IDs
          let captionsUrl = null;

          // First try the specific field that contains captions URL
          if (
            sceneData?.['field_6910'] &&
            typeof sceneData['field_6910'] === 'string' &&
            (sceneData['field_6910'].startsWith('http') ||
              sceneData['field_6910'].includes('.json'))
          ) {
            captionsUrl = sceneData['field_6910'];
          }

          // Then try other possible field names
          if (!captionsUrl) {
            captionsUrl =
              sceneData?.['Captions URL'] ||
              sceneData?.['captions_url'] ||
              sceneData?.['CaptionsURL'] ||
              sceneData?.['captions URL'];
          }

          // Finally try other field IDs that might contain captions (only if they look like URLs)
          if (!captionsUrl) {
            const possibleFields = [
              'field_6892',
              'field_6893',
              'field_6894',
              'field_6895',
              'field_6897',
              'field_6898',
              'field_6899',
            ];
            for (const field of possibleFields) {
              const value = sceneData?.[field];
              if (
                value &&
                typeof value === 'string' &&
                (value.startsWith('http') || value.includes('.json'))
              ) {
                captionsUrl = value;
                break;
              }
            }
          }

          if (captionsUrl) {
            const response = await fetch(captionsUrl as string);
            if (response.ok) {
              const data = await response.json();
              setTranscriptionWords(data);
            } else {
              setTranscriptionWords(null);
            }
          } else {
            setTranscriptionWords(null);
          }
        } catch (error) {
          console.error('Failed to fetch transcription:', error);
          setTranscriptionWords(null);
        }
      };
      fetchTranscription();
    } else {
      // Modal is closed, clear transcription data
      setTranscriptionWords(null);
    }
  }, [isOpen, sceneId, refetchTrigger, videoUrl]);

  // Handle keyboard controls
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const stopAll = () => {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
      };

      if (event.code === 'Escape') {
        stopAll();
        // 1) Exit preview if open
        if (previewUrl) {
          setPreviewUrl(null);
          return;
        }

        // 2) Clear overlays on canvas first (image/text)
        if (overlayImageUrl || selectedWordText) {
          if (overlayImageUrl) {
            handleRemoveImage();
          }
          if (selectedWordText) {
            setSelectedWordText(null);
            setCustomText('');
          }
          return;
        }

        // 3) Nothing to clear -> close modal
        handleClose();
        return;
      }

      if (
        event.key === '1' &&
        !event.ctrlKey &&
        !event.metaKey &&
        !event.altKey
      ) {
        // If an input or editable element is focused, allow typing.
        const target = event.target as Element | null;
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return;
        }

        stopAll();
        const video = previewUrl ? previewVideoRef.current : videoRef.current;
        if (video) {
          video.currentTime = 0;
          video.play().catch(() => {
            // Ignore autoplay/gesture errors; user explicitly pressed a key.
          });
        }
        return;
      }

      if (event.code === 'Space') {
        // If an input or editable element is focused, allow the spacebar to
        // insert text rather than control player playback.
        const target = event.target as Element | null;
        if (
          target instanceof HTMLInputElement ||
          target instanceof HTMLTextAreaElement ||
          target instanceof HTMLSelectElement ||
          (target instanceof HTMLElement && target.isContentEditable)
        ) {
          return; // allow normal typing behavior
        }

        stopAll();
        const video = previewUrl ? previewVideoRef.current : videoRef.current;
        if (video) {
          if (video.paused) {
            video.play();
          } else {
            video.pause();
          }
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener('keydown', handleKeyDown, {
        capture: true,
      });
    };
  }, [
    previewUrl,
    handleClose,
    overlayImageUrl,
    selectedWordText,
    handleRemoveImage,
  ]);

  // Update container dimensions
  useEffect(() => {
    const updateContainerRect = () => {
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    };

    // Update immediately
    updateContainerRect();

    // Update on window resize
    window.addEventListener('resize', updateContainerRect);
    return () => window.removeEventListener('resize', updateContainerRect);
  }, [getVideoContentRect]);

  // Prevent scrolling the page behind the modal.
  useEffect(() => {
    if (!isOpen) return;

    const html = document.documentElement;
    const body = document.body;

    const prevHtmlOverflow = html.style.overflow;
    const prevBodyOverflow = body.style.overflow;
    const prevBodyPaddingRight = body.style.paddingRight;

    const scrollbarWidth = Math.max(0, window.innerWidth - html.clientWidth);

    html.style.overflow = 'hidden';
    body.style.overflow = 'hidden';
    if (scrollbarWidth > 0) {
      body.style.paddingRight = `${scrollbarWidth}px`;
    }

    return () => {
      html.style.overflow = prevHtmlOverflow;
      body.style.overflow = prevBodyOverflow;
      body.style.paddingRight = prevBodyPaddingRight;
    };
  }, [isOpen]);

  // Update container dimensions
  useEffect(() => {
    const updateContainerRect = () => {
      const rect = getVideoContentRect();
      if (rect) {
        setContainerRect({ width: rect.width, height: rect.height });
      }
    };

    // Update immediately
    updateContainerRect();

    // Update on window resize
    window.addEventListener('resize', updateContainerRect);
    return () => window.removeEventListener('resize', updateContainerRect);
  }, [getVideoContentRect]);

  if (!isOpen) return null;

  return (
    <div className='fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50'>
      <div className='bg-white rounded-lg p-8 w-full mx-2 h-[95vh] overflow-hidden flex flex-col'>
        <div className='flex justify-between items-center mb-4'>
          <h2 className='text-xl font-semibold'>Add Image Overlay</h2>
          <button
            onClick={handleClose}
            className='p-1 hover:bg-gray-100 rounded'
          >
            <X className='h-5 w-5' />
          </button>
        </div>

        <div className='grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1 min-h-0 items-start'>
          {/* Video Preview */}
          <div
            className='relative lg:col-span-2 w-full aspect-video self-start'
            onPointerDown={isEditingTintArea ? undefined : handleMouseDown}
            onPointerMove={isEditingTintArea ? undefined : handlePointerMove}
            onPointerLeave={handlePointerLeave}
          >
            {originalVideoUrl ? (
              <video
                key={originalVideoUrl}
                ref={videoRef}
                src={originalVideoUrl}
                className='w-full h-full object-contain object-top rounded border'
                controls
                crossOrigin='anonymous'
                onLoadedMetadata={handleVideoLoad}
              />
            ) : (
              <div className='w-full h-full flex items-center justify-center bg-gray-100 rounded border'>
                <div className='text-gray-500 text-center'>
                  <div className='text-lg mb-2'>📹</div>
                  <div>Loading video...</div>
                </div>
              </div>
            )}
            {shouldShowTintOverlay && videoTintColor && (
              <>
                {!tintInvert ? (
                  <div
                    className='absolute pointer-events-none'
                    style={{
                      left: `${tintRect.left}%`,
                      top: `${tintRect.top}%`,
                      width: `${tintRect.width}%`,
                      height: `${tintRect.height}%`,
                      backgroundColor: videoTintColor,
                      opacity: clamp01(videoTintOpacity),
                    }}
                  />
                ) : (
                  <>
                    {tintRect.top > 0 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: 0,
                          top: 0,
                          right: 0,
                          height: `${tintRect.top}%`,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                    {tintRect.bottom < 100 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: 0,
                          top: `${tintRect.bottom}%`,
                          right: 0,
                          bottom: 0,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                    {tintRect.left > 0 && tintRect.height > 0 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: 0,
                          top: `${tintRect.top}%`,
                          width: `${tintRect.left}%`,
                          height: `${tintRect.height}%`,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                    {tintRect.right < 100 && tintRect.height > 0 && (
                      <div
                        className='absolute pointer-events-none'
                        style={{
                          left: `${tintRect.right}%`,
                          top: `${tintRect.top}%`,
                          right: 0,
                          height: `${tintRect.height}%`,
                          backgroundColor: videoTintColor,
                          opacity: clamp01(videoTintOpacity),
                        }}
                      />
                    )}
                  </>
                )}
              </>
            )}

            {isEditingTintArea && (
              <div
                className='absolute pointer-events-auto z-30'
                style={{
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: '40px',
                }}
                onPointerDown={handleTintMouseDown}
                onPointerMove={handleTintPointerMove}
                onPointerLeave={handlePointerLeave}
              >
                <div
                  className='absolute border-2 border-blue-500'
                  style={{
                    left: `${tintRect.left}%`,
                    top: `${tintRect.top}%`,
                    width: `${tintRect.width}%`,
                    height: `${tintRect.height}%`,
                  }}
                />
              </div>
            )}
            {/* Invisible overlay to capture clicks when there's an overlay - excludes controls area */}
            {overlayImageUrl && (
              <div
                className='absolute pointer-events-auto z-5'
                style={{
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: '40px', // Leave space for video controls at bottom
                }}
                onPointerDown={(e) => {
                  // Only prevent default if clicking in overlay area
                  const contentRect = getVideoContentRect();
                  if (!contentRect) return;

                  const x = e.clientX - contentRect.left;
                  const y = e.clientY - contentRect.top;

                  const overlayX = overlayPosition.x - overlaySize.width / 2;
                  const overlayY = overlayPosition.y - overlaySize.height / 2;
                  const overlayX_px = (overlayX / 100) * contentRect.width;
                  const overlayY_px = (overlayY / 100) * contentRect.height;
                  const overlayWidth_px =
                    (overlaySize.width / 100) * contentRect.width;
                  const overlayHeight_px =
                    (overlaySize.height / 100) * contentRect.height;

                  // If clicking within overlay bounds, handle overlay interaction
                  if (
                    x >= overlayX_px &&
                    x <= overlayX_px + overlayWidth_px &&
                    y >= overlayY_px &&
                    y <= overlayY_px + overlayHeight_px
                  ) {
                    handleMouseDown(e);
                  } else {
                    // Outside overlay - allow video surface clicks (but not controls)
                    // This will still prevent accidental play/pause on video surface
                    e.preventDefault();
                  }
                }}
              />
            )}
            {overlayImageUrl && (
              <div
                className='absolute border-2 border-blue-500 cursor-move pointer-events-auto z-20'
                style={{
                  left: `${overlayPosition.x}%`,
                  top: `${overlayPosition.y}%`,
                  width: `${overlaySize.width}%`,
                  height: `${overlaySize.height}%`,
                  transform: 'translate(-50%, -50%)',
                }}
                onPointerDown={handleMouseDown}
                onWheel={handleOverlayWheelZoom}
              >
                <img
                  src={overlayImageUrl}
                  alt='Overlay'
                  className='w-full h-full object-contain'
                  draggable={false}
                  onPointerDown={handleMouseDown}
                />
              </div>
            )}
            {selectedWordText && (
              <div
                className='absolute border border-green-500 cursor-move pointer-events-auto z-10 rounded'
                style={{
                  left: `${textOverlayPosition.x}%`,
                  top: `${textOverlayPosition.y}%`,
                  transform: 'translate(-50%, -50%)',
                  width: `${Math.max(
                    5,
                    Math.min(
                      95,
                      (selectedWordText.length <= 3
                        ? 35
                        : selectedWordText.length <= 7
                        ? 55
                        : selectedWordText.length <= 12
                        ? 70
                        : 85) *
                        (textOverlaySize.width / 20)
                    ) * 0.5
                  )}%`,
                  height: `${Math.max(
                    5,
                    Math.max(
                      10,
                      Math.min(85, (textOverlaySize.width / 100) * 60)
                    ) * 0.5
                  )}%`,
                  // Match server-side font sizing (in video pixels), then scale to CSS pixels.
                  fontSize: `${(() => {
                    const v = videoRef.current;
                    if (!v?.videoWidth || !v?.videoHeight) {
                      return Math.max(8, (textOverlaySize.width / 100) * 120);
                    }
                    const fontSizeVideoPx = Math.max(
                      16,
                      Math.min(
                        500,
                        (textOverlaySize.width / 100) *
                          Math.min(v.videoWidth, v.videoHeight) *
                          0.2
                      )
                    );
                    return Math.max(1, fontSizeVideoPx * videoToCssScale);
                  })()}px`,
                }}
                onPointerDown={handleTextMouseDown}
                onWheel={handleTextOverlayWheelZoom}
              >
                <div
                  className='w-full h-full flex items-center justify-center font-bold select-none whitespace-nowrap'
                  style={{
                    color: textStyling.fontColor,
                    textShadow: `${textStyling.shadowX * videoToCssScale}px ${
                      textStyling.shadowY * videoToCssScale
                    }px 0px rgba(${hexToRgb(textStyling.shadowColor)}, ${
                      textStyling.shadowOpacity
                    })`,
                    WebkitTextStroke:
                      textStyling.borderWidth > 0
                        ? `${textStyling.borderWidth * videoToCssScale}px ${
                            textStyling.borderColor
                          }`
                        : 'none',
                    fontWeight: 'bold',
                    fontFamily: textStyling.fontFamily,
                    backgroundColor: textStyling.bgColor
                      ? `rgba(${hexToRgb(textStyling.bgColor)}, ${
                          textStyling.bgOpacity ?? 1
                        })`
                      : undefined,
                    padding: textStyling.bgSize
                      ? `${textStyling.bgSize * videoToCssScale}px`
                      : undefined,
                    borderRadius: textStyling.bgSize ? '4px' : undefined,
                  }}
                >
                  {selectedWordText}
                </div>
              </div>
            )}
          </div>

          {/* Controls */}
          <div className='space-y-4 overflow-y-auto min-h-0 self-stretch h-full pr-1'>
            {/* Image Upload */}
            <ImageUploadRow
              fileInputRef={fileInputRef}
              overlayImage={overlayImage}
              onImageUpload={handleImageUpload}
              onPickFile={() => fileInputRef.current?.click()}
              onScreenshot={handleScreenshot}
              onCopyToClipboard={handleCopyOverlayImageToClipboard}
              onPasteFromClipboard={handlePasteOverlayImageFromClipboard}
              onRemoveImage={handleRemoveImage}
            />

            {/* Position Controls */}
            {/* Position and Size Controls */}
            {overlayImageUrl && (
              <ImagePositionControls
                overlayPosition={overlayPosition}
                setOverlayPosition={setOverlayPosition}
                overlaySize={overlaySize}
                setOverlaySize={setOverlaySize}
                actualImageDimensions={actualImageDimensions}
                onCrop={() => {
                  setCropBorderRadius(0);
                  setCropEditorMode('crop');
                  setCropShape('rectangle');
                  setCropRotationDegrees(0);
                  setCropAdjustments({
                    brightness: 0,
                    contrast: 0,
                    saturation: 0,
                    hue: 0,
                  });
                  setCropperModalKey((k) => k + 1);
                  setIsCropping(true);
                }}
                onCenterResetNatural={() => {
                  setOverlayPosition({ x: 50, y: 50 });
                  void (async () => {
                    const dims =
                      actualImageDimensions ??
                      (await ensureOverlayImageDimensions());
                    if (dims) {
                      setOverlaySizeFromPixels(dims.width, dims.height);
                      return;
                    }
                    setOverlaySize({ width: 25, height: 25 });
                  })();
                }}
                onCenterMaximize={() => {
                  setOverlayPosition({ x: 50, y: 50 });
                  setOverlaySize({ width: 100, height: 100 });
                }}
                onZoomOut={() => {
                  setOverlaySize((prev) => ({
                    width: Math.max(5, prev.width * 0.9),
                    height: Math.max(5, prev.height * 0.9),
                  }));
                }}
                onZoomIn={() => {
                  setOverlaySize((prev) => ({
                    width: Math.min(100, prev.width * 1.1),
                    height: Math.min(100, prev.height * 1.1),
                  }));
                }}
              />
            )}

            {/* Timing Controls */}
            <TimingTintControls
              startTime={startTime}
              endTime={endTime}
              setStartTime={(v) => setStartTime(v)}
              setEndTime={(v) => setEndTime(v)}
              onSetStartFromCurrent={() => {
                const video = videoRef.current;
                if (video) setStartTime(video.currentTime);
              }}
              onSetEndFromCurrent={() => {
                const video = videoRef.current;
                if (video) setEndTime(video.currentTime);
              }}
              isTintSectionOpen={isTintSectionOpen}
              setIsTintSectionOpen={setIsTintSectionOpen}
              tintPalette={tintPalette}
              videoTintColor={videoTintColor}
              setVideoTintColor={setVideoTintColor}
              videoTintOpacity={videoTintOpacity}
              setVideoTintOpacity={setVideoTintOpacity}
              clamp01={clamp01}
              isEditingTintArea={isEditingTintArea}
              setIsEditingTintArea={setIsEditingTintArea}
              tintInvert={tintInvert}
              setTintInvert={setTintInvert}
            />

            <div className='mt-2 grid grid-cols-2 gap-2'>
              <div className='bg-gray-50 p-2 rounded-lg border border-gray-200'>
                <div
                  role='button'
                  tabIndex={0}
                  onClick={() => setIsSoundSectionOpen((s) => !s)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      setIsSoundSectionOpen((s) => !s);
                    }
                  }}
                  className='w-full flex items-center justify-between gap-2 text-sm text-gray-700 cursor-pointer select-none'
                  aria-expanded={isSoundSectionOpen}
                >
                  <div className='flex items-center gap-2 min-w-0'>
                    <span>Sound</span>
                    {!isSoundSectionOpen && (
                      <span className='text-xs text-gray-500 truncate'>
                        {selectedSoundName ?? 'None'}
                      </span>
                    )}
                  </div>

                  <div className='flex items-center gap-2'>
                    <button
                      type='button'
                      onClick={(e) => {
                        e.stopPropagation();
                        setSelectedSoundName(null);
                      }}
                      className={`px-2 py-1 text-xs rounded border bg-white ${
                        !selectedSoundName
                          ? 'border-gray-700 text-gray-900'
                          : 'border-gray-300 text-gray-700'
                      }`}
                    >
                      None
                    </button>
                    {isSoundSectionOpen ? (
                      <ChevronDown className='h-4 w-4' />
                    ) : (
                      <ChevronRight className='h-4 w-4' />
                    )}
                  </div>
                </div>

                {isSoundSectionOpen && (
                  <div className='mt-2 flex flex-wrap gap-2'>
                    {availableSounds.map((s) => (
                      <button
                        key={s.name}
                        type='button'
                        onClick={() => setSelectedSoundName(s.name)}
                        className={`px-2 py-1 text-xs rounded border bg-white ${
                          selectedSoundName === s.name
                            ? 'border-gray-700 text-gray-900'
                            : 'border-gray-300 text-gray-700'
                        }`}
                        title={s.name}
                      >
                        {s.name}
                      </button>
                    ))}

                    {availableSounds.length === 0 && (
                      <span className='text-xs text-gray-500'>
                        No sounds found in /public/sounds
                      </span>
                    )}
                  </div>
                )}
              </div>

              <div className='bg-gray-50 p-2 rounded-lg border border-gray-200'>
                <div
                  role='button'
                  tabIndex={0}
                  onClick={() => setIsAnimationSectionOpen((s) => !s)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      setIsAnimationSectionOpen((s) => !s);
                    }
                  }}
                  className='w-full flex items-center justify-between gap-2 text-sm text-gray-700 cursor-pointer select-none'
                  aria-expanded={isAnimationSectionOpen}
                >
                  <div className='flex items-center gap-2 min-w-0'>
                    <span>Animation</span>
                    {!isAnimationSectionOpen && (
                      <span className='text-xs text-gray-500 truncate'>
                        {animationLabel}
                      </span>
                    )}
                  </div>

                  <div className='flex items-center gap-2'>
                    <button
                      type='button'
                      onClick={(e) => {
                        e.stopPropagation();
                        setOverlayAnimation('none');
                      }}
                      className={`px-2 py-1 text-xs rounded border bg-white ${
                        overlayAnimation === 'none'
                          ? 'border-gray-700 text-gray-900'
                          : 'border-gray-300 text-gray-700'
                      }`}
                    >
                      None
                    </button>
                    {isAnimationSectionOpen ? (
                      <ChevronDown className='h-4 w-4' />
                    ) : (
                      <ChevronRight className='h-4 w-4' />
                    )}
                  </div>
                </div>

                {isAnimationSectionOpen && (
                  <div className='mt-2 grid grid-cols-3 gap-2'>
                    {(
                      [
                        { id: 'bounceIn', label: 'Bounce In' },
                        { id: 'spring', label: 'Spring' },
                        { id: 'fadeIn', label: 'Fade In' },
                        { id: 'miniZoom', label: 'Mini Zoom' },
                        { id: 'zoomIn', label: 'Zoom In' },
                        { id: 'slideLeft', label: 'Slide Left' },
                        { id: 'slideRight', label: 'Slide Right' },
                        { id: 'slideUp', label: 'Slide Up' },
                      ] as const
                    ).map((opt) => (
                      <button
                        key={opt.id}
                        type='button'
                        onClick={() => setOverlayAnimation(opt.id)}
                        className={`px-2 py-2 text-xs rounded border bg-white text-left ${
                          overlayAnimation === opt.id
                            ? 'border-gray-700 text-gray-900'
                            : 'border-gray-300 text-gray-700'
                        }`}
                      >
                        {opt.label}
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>

            <TranscriptionControls
              transcriptionWords={transcriptionWords}
              customText={customText}
              selectedWordText={selectedWordText}
              onWordClick={(wordData) => {
                setStartTime(wordData.start);
                const raw = (wordData.word || '').trim();
                const cleaned = raw.replace(/[，,]+$/g, '').trim();
                setCustomText(cleaned.toUpperCase());
                if (videoRef.current) {
                  videoRef.current.currentTime = wordData.start;
                }
              }}
              onWordRightClick={(wordData) => {
                const t = Number.isFinite(wordData.end)
                  ? Math.max(0, wordData.end)
                  : 0;
                setEndTime(t);
              }}
              onWordDoubleClick={(wordData) => {
                setStartTime(wordData.start);
                const raw = (wordData.word || '').trim();
                const cleaned = raw.replace(/[，,]+$/g, '').trim();
                const text = cleaned.toUpperCase();

                // Match + button behavior: set input and add to canvas (text overlay), and clear image overlay.
                setCustomText(text);
                setSelectedWordText(text);
                setOverlayImage(null);
                setOverlayImageUrl(null);
                if (fileInputRef.current) fileInputRef.current.value = '';

                if (videoRef.current) {
                  videoRef.current.currentTime = wordData.start;
                }
              }}
              onCustomTextChange={setCustomText}
              onCustomTextEnter={() => {
                if (customText.trim()) {
                  setSelectedWordText(customText.trim());
                  setOverlayImage(null);
                  setOverlayImageUrl(null);
                  if (fileInputRef.current) fileInputRef.current.value = '';
                }
              }}
              onAddText={() => {
                if (customText.trim()) {
                  setSelectedWordText(customText.trim());
                  setOverlayImage(null);
                  setOverlayImageUrl(null);
                  if (fileInputRef.current) fileInputRef.current.value = '';
                }
              }}
              onClearText={() => {
                setSelectedWordText(null);
                setCustomText('');
                setPreviewUrl(null);
              }}
              onInsertFull={() => {
                if (transcriptionWords && transcriptionWords.length > 0) {
                  const allText = transcriptionWords
                    .map((w) => w.word)
                    .join(' ');
                  setCustomText((allText || '').toUpperCase());
                }
              }}
              canTranscribe={!!handleTranscribeScene}
              onTranscribe={async () => {
                if (!handleTranscribeScene) return;
                setIsTranscribing(true);
                try {
                  await handleTranscribeScene(sceneId, undefined, 'final');
                  if (
                    !useAppStore.getState().batchOperations
                      .transcribingAllFinalScenes
                  ) {
                    setRefetchTrigger((prev) => prev + 1);
                  }
                } catch (error) {
                  console.error('Failed to transcribe:', error);
                } finally {
                  setIsTranscribing(false);
                }
              }}
              onRetranscribe={async () => {
                if (!handleTranscribeScene) return;
                setIsTranscribing(true);
                try {
                  await handleTranscribeScene(sceneId, undefined, 'final');
                  if (
                    !useAppStore.getState().batchOperations
                      .transcribingAllFinalScenes
                  ) {
                    setRefetchTrigger((prev) => prev + 1);
                  }
                } catch (error) {
                  console.error('Failed to retranscribe:', error);
                } finally {
                  setIsTranscribing(false);
                }
              }}
              isTranscribing={isTranscribing}
              isInsertFullDisabled={
                !transcriptionWords ||
                transcriptionWords.length === 0 ||
                customText.trim() ===
                  (transcriptionWords || [])
                    .map((w) => w.word)
                    .join(' ')
                    .trim()
              }
            />

            {selectedWordText && (
              <TextOverlayControls
                textOverlayPosition={textOverlayPosition}
                setTextOverlayPosition={setTextOverlayPosition}
                textOverlaySize={textOverlaySize}
                setTextOverlaySize={setTextOverlaySize}
                isTextStylingSectionOpen={isTextStylingSectionOpen}
                setIsTextStylingSectionOpen={setIsTextStylingSectionOpen}
                textStyling={textStyling}
                setTextStyling={setTextStyling}
                ffmpegFonts={ffmpegFonts as Record<string, string>}
                availableFontFamilies={availableFontFamilies}
                showFontPreview={showFontPreview}
                setShowFontPreview={setShowFontPreview}
                isFontLoaded={isFontLoaded}
                saveCurrentTextStyle={saveCurrentTextStyle}
                savedTextStyles={savedTextStyles}
                applySavedTextStyle={applySavedTextStyle}
                deleteSavedTextStyle={deleteSavedTextStyle}
              />
            )}
          </div>
        </div>

        {/* Action Buttons */}
        <div className='flex justify-end space-x-3 mt-6 pt-4 border-t'>
          <button
            onClick={handleClose}
            className='px-4 py-2 text-gray-600 hover:bg-gray-100 rounded'
            disabled={isApplying}
          >
            Cancel
          </button>
          <button
            onClick={handlePreview}
            disabled={
              !(overlayImage || selectedWordText || videoTintColor) ||
              isApplying
            }
            className='px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed'
          >
            Preview
          </button>
          <button
            onClick={handleApply}
            disabled={
              !(overlayImage || selectedWordText || videoTintColor) ||
              isApplying
            }
            className='flex items-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed'
          >
            {isApplying ? (
              <Loader2 className='animate-spin h-4 w-4' />
            ) : (
              <span>Apply Overlay</span>
            )}
          </button>
        </div>
      </div>

      {/* Cropping Modal */}
      {isCropping && overlayImageUrl && (
        <div className='fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'>
          <div className='bg-white rounded-lg p-6 max-w-4xl max-h-[90vh] w-full mx-4'>
            <div className='flex justify-between items-center mb-4'>
              <h3 className='text-lg font-semibold'>Crop Image</h3>
              <button
                onClick={() => {
                  setIsCropping(false);
                }}
                className='p-1 hover:bg-gray-100 rounded'
              >
                <X className='h-5 w-5' />
              </button>
            </div>

            <div className='flex flex-col items-center space-y-4'>
              <div className='flex space-x-4 w-full'>
                <div className='flex-1'>
                  <h4 className='text-sm font-medium mb-2'>Select Crop Area</h4>
                  <div className='max-h-[50vh] overflow-auto border rounded'>
                    <div
                      className='relative h-96 w-full border bg-gray-100'
                      style={{ minHeight: '384px' }}
                    >
                      <Cropper
                        key={`${overlayImageUrl}-${cropperModalKey}`}
                        src={overlayImageUrl}
                        ref={cropperRef}
                        className={'w-full h-full'}
                        style={{
                          height: '100%',
                          width: '100%',
                          backgroundColor: '#f3f4f6',
                          ['--crop-stencil-radius' as never]: `${cropBorderRadius}%`,
                        }}
                        stencilProps={{
                          aspectRatio: undefined,
                          movable: cropEditorMode === 'crop',
                          resizable: cropEditorMode === 'crop',
                          lines: cropEditorMode === 'crop',
                          handlers: cropEditorMode === 'crop',
                          previewClassName:
                            cropShape === 'rectangle'
                              ? 'overflow-hidden rounded-[var(--crop-stencil-radius)]'
                              : undefined,
                          boundingBoxClassName:
                            cropShape === 'rectangle'
                              ? 'rounded-[var(--crop-stencil-radius)]'
                              : undefined,
                          overlayClassName:
                            cropEditorMode === 'crop'
                              ? undefined
                              : 'opacity-50',
                        }}
                        backgroundWrapperProps={{
                          scaleImage: cropEditorMode === 'crop',
                          moveImage: cropEditorMode === 'crop',
                        }}
                        stencilComponent={
                          cropShape === 'circle' ? CircleStencil : undefined
                        }
                        {...(!isGifOverlay
                          ? {
                              backgroundComponent: AdjustableCropperBackground,
                              backgroundProps: cropAdjustments,
                            }
                          : {})}
                        checkOrientation={false}
                        onReady={() => {
                          console.log(
                            'Cropper ready, ref:',
                            cropperRef.current
                          );
                        }}
                      />
                    </div>
                  </div>
                </div>
              </div>

              <div className='flex flex-wrap items-center justify-center gap-2 w-full'>
                <button
                  type='button'
                  onClick={() => setCropEditorMode('crop')}
                  className={`px-3 py-2 border rounded hover:bg-gray-50 ${
                    cropEditorMode === 'crop'
                      ? 'bg-gray-100'
                      : 'border-gray-300'
                  }`}
                >
                  Crop
                </button>
                {(
                  [
                    ['brightness', 'Brightness'],
                    ['contrast', 'Contrast'],
                    ['saturation', 'Saturation'],
                    ['hue', 'Hue'],
                  ] as const
                ).map(([key, label]) => (
                  <button
                    key={key}
                    type='button'
                    onClick={() => setCropEditorMode(key)}
                    disabled={isGifOverlay}
                    className={`px-3 py-2 border rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed ${
                      cropEditorMode === key ? 'bg-gray-100' : 'border-gray-300'
                    }`}
                  >
                    {label}
                  </button>
                ))}
              </div>

              {cropEditorMode !== 'crop' && !isGifOverlay && (
                <div className='flex items-center gap-3 w-full'>
                  <label className='text-sm text-gray-700 w-24'>
                    {cropEditorMode.charAt(0).toUpperCase() +
                      cropEditorMode.slice(1)}
                  </label>
                  <input
                    type='range'
                    min={-1}
                    max={1}
                    step={0.01}
                    value={cropAdjustments[cropEditorMode]}
                    onChange={(e) => {
                      const v = Number(e.target.value);
                      setCropAdjustments((prev) => ({
                        ...prev,
                        [cropEditorMode]: v,
                      }));
                    }}
                    className='flex-1'
                  />
                  <span className='text-sm text-gray-700 w-16 text-right'>
                    {Math.round(cropAdjustments[cropEditorMode] * 100)}%
                  </span>
                </div>
              )}

              {cropEditorMode === 'crop' && (
                <div className='flex flex-wrap items-center justify-center gap-3 w-full'>
                  <button
                    type='button'
                    onClick={() => setCropShape('rectangle')}
                    className={`px-3 py-2 border rounded hover:bg-gray-50 ${
                      cropShape === 'rectangle'
                        ? 'bg-gray-100'
                        : 'border-gray-300'
                    }`}
                  >
                    Rectangle
                  </button>
                  <button
                    type='button'
                    onClick={() => setCropShape('circle')}
                    disabled={isGifOverlay}
                    className={`px-3 py-2 border rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed ${
                      cropShape === 'circle' ? 'bg-gray-100' : 'border-gray-300'
                    }`}
                  >
                    Circle
                  </button>

                  <button
                    type='button'
                    onClick={() => {
                      const current =
                        cropperRef.current?.getTransforms()?.rotate ??
                        cropRotationDegrees;
                      setCropRotationAbsolute(current - 90);
                    }}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Rotate Left
                  </button>
                  <button
                    type='button'
                    onClick={() => {
                      const current =
                        cropperRef.current?.getTransforms()?.rotate ??
                        cropRotationDegrees;
                      setCropRotationAbsolute(current + 90);
                    }}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Rotate Right
                  </button>

                  <div className='flex items-center gap-2 min-w-[260px]'>
                    <label className='text-sm text-gray-700'>Rotate (°)</label>
                    <input
                      type='range'
                      min={-180}
                      max={180}
                      step={1}
                      value={cropRotationDegrees}
                      onChange={(e) =>
                        setCropRotationAbsolute(Number(e.target.value))
                      }
                      disabled={isGifOverlay}
                      className='flex-1 disabled:opacity-50 disabled:cursor-not-allowed'
                    />
                    <input
                      type='number'
                      min={-180}
                      max={180}
                      step={1}
                      value={cropRotationDegrees}
                      onChange={(e) =>
                        setCropRotationAbsolute(Number(e.target.value))
                      }
                      disabled={isGifOverlay}
                      className='w-20 px-2 py-1 border border-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed'
                    />
                  </div>
                  <button
                    type='button'
                    onClick={() => cropperRef.current?.flipImage(true, false)}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Flip Horizontal
                  </button>
                  <button
                    type='button'
                    onClick={() => cropperRef.current?.flipImage(false, true)}
                    disabled={isGifOverlay}
                    className='px-3 py-2 border border-gray-300 rounded hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
                  >
                    Flip Vertical
                  </button>

                  <div className='flex items-center gap-2 min-w-[280px]'>
                    <label className='text-sm text-gray-700'>
                      Border radius
                    </label>
                    <input
                      type='range'
                      min={0}
                      max={100}
                      value={cropBorderRadius}
                      onChange={(e) =>
                        setCropBorderRadius(Number(e.target.value))
                      }
                      disabled={isGifOverlay || cropShape === 'circle'}
                      className='flex-1 disabled:opacity-50 disabled:cursor-not-allowed'
                    />
                    <span className='text-sm text-gray-700 w-12 text-right'>
                      {cropBorderRadius}%
                    </span>
                  </div>
                </div>
              )}

              <div className='flex space-x-2'>
                <button
                  onClick={() => {
                    setIsCropping(false);
                  }}
                  className='px-4 py-2 border border-gray-300 rounded hover:bg-gray-50'
                >
                  Cancel
                </button>
                <button
                  onClick={async () => {
                    console.log(
                      'Apply crop clicked, cropperRef.current:',
                      cropperRef.current
                    );
                    console.log('overlayImage:', overlayImage);
                    if (cropperRef.current && overlayImage) {
                      console.log('Calling applyCrop');
                      await applyCrop();
                    } else {
                      console.log('Conditions not met for applyCrop');
                    }
                  }}
                  className='px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600'
                  disabled={!overlayImage}
                >
                  Apply Crop
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Preview Video Overlay */}
      {previewUrl && (
        <div
          className='fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'
          onClick={() => setPreviewUrl(null)}
        >
          <div className='relative max-w-4xl max-h-[80vh] w-full mx-4'>
            <button
              onClick={(e) => {
                e.stopPropagation();
                setPreviewUrl(null);
              }}
              className='absolute -top-10 right-0 text-white hover:text-gray-300 text-xl font-bold'
            >
              ✕
            </button>
            <video
              src={previewUrl as string}
              controls
              autoPlay
              crossOrigin='anonymous'
              className='w-full h-full rounded-lg'
              onClick={(e) => e.stopPropagation()}
              ref={previewVideoRef}
            />
          </div>
        </div>
      )}
    </div>
  );
};
